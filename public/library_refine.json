[
  {
    "insight_id": 1,
    "taxonomy": {
      "General Formulation": {
        "Units Scaling": [
          "Unit Conversion & Consistency"
        ]
      }
    },
    "condition": "This insight applies when input data come in different unit systems or incompatible measurement scales. For example, when the problem statement mentioned feed prices in \u00a5/kg while the failed mathematical model used \u00a5/g without consistent conversion.",
    "explanation": "When the problem involves different units, the best practice is to convert all quantities to a consistent unit system. A common mistake is failing to maintain unit consistency, which happens because of oversight in conversion between different units, leading to incorrect calculations. More generally, this reflects that consistent unit scaling is crucial for accuracy in optimization models.",
    "example": "# Wrong: C_i = 0.0002 (\u00a5/g) \n# Correct: C_i = 0.2 (\u00a5/kg)",
    "iteration": 0,
    "version": 1,
    "task_id": "B029",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "B029"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 2,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision quantities in the problem represent divisible amounts such as flows. For example, when the problem statement involves determining the amount of feed, which can be fractional rather than discrete.\nThis insight applies when decision quantities involve fractional or continuous amounts, such as servings, portions, or consumable resources, or aim to optimize under constraints. For example, when the problem statement mentions items like food components, supplements, or catalysts.\nThis insight does NOT apply when decision quantities represent discrete events, whole activities, or require integer solutions. For example, when the problem statement involves selecting combinations of food items, choosing whole units due to practical constraints, or deciding the number of times a process should be used.",
    "explanation": "When the problem involves continuous decision quantities, the best practice is to define decision variables as continuous. A common mistake is using discrete variable definitions, which happens because of a misunderstanding of the divisibility of the quantities involved. More generally, this reflects that understanding the nature of decision variables is essential for correct variable definition.",
    "example": "# Wrong: x_i as integer \n# Correct: x_i as continuous",
    "iteration": 0,
    "version": 1,
    "task_id": "B029",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B029",
        "B096",
        "F091",
        "A104",
        "F019",
        "B031",
        "B039",
        "E071",
        "E069",
        "F167",
        "A236",
        "A084",
        "E061",
        "E059",
        "E067",
        "E066",
        "E052",
        "E103"
      ],
      "negative": [
        "F192",
        "E023",
        "E029",
        "E021",
        "E003",
        "E017",
        "E019",
        "E001",
        "E014",
        "E030",
        "E004",
        "E012",
        "E005",
        "E007",
        "E028",
        "E033",
        "E020",
        "E013",
        "E024",
        "E034",
        "A179",
        "A112",
        "A093",
        "F088",
        "F126",
        "E002",
        "E006",
        "E011",
        "E009",
        "F080"
      ],
      "unretrieved": [
        "A171",
        "A180",
        "A176",
        "A223",
        "E025",
        "A172"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 3,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Explicit Bounds"
        ]
      }
    },
    "condition": "This insight applies when the problem description provides natural physical, economic, or logical limits that can tightly bound decision variables. For example, when the problem statement involved food items that are typically purchased in integer units.",
    "explanation": "When the problem involves decision variables that have natural bounds, the best practice is to explicitly set these bounds to improve solver efficiency and model accuracy. A common mistake is to leave these bounds unspecified, which happens because of oversight or assumption that the solver will implicitly handle them. More generally, this reflects that setting explicit bounds can aid in model stability and solution quality.",
    "example": "# Wrong\nx_i \\geq 0  # Non-negative constraints only\n\n# Correct\nx = model.addVars(protein_content.keys(), vtype=GRB.INTEGER, name='x', lb=0)  # Explicit non-negativity bound",
    "iteration": 0,
    "version": 1,
    "task_id": "E021",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 4,
    "taxonomy": {
      "Domain Modeling": {
        "Knapsack Constraints": [
          "definition",
          "condition"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves selecting items while minimizing a scalar capacity such as cost. For example, when the problem aims to minimize the cost of a meal plan while meeting nutritional requirements.",
    "explanation": "When the problem involves selecting items with a minimum cost while satisfying constraints, the best practice is to ensure that the model correctly captures the constraints and objectives typical of a knapsack problem. A common mistake is to overlook integer constraints, which happens because the formulation might implicitly assume continuous variables. More generally, this reflects that alignment with the problem's combinatorial nature is essential for correct formulation.",
    "example": "# Wrong: Minimize cost without integer constraints\nmodel.setObjective(2*x1 + 3*x2 + 3*x3 + 2*x4 + 4*x5 + 10*x6, GRB.MINIMIZE)\n\n# Correct: Include integer constraints for selection\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"Chicken\")",
    "iteration": 0,
    "version": 1,
    "task_id": "E019",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 5,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision quantities in the problem represent indivisible counts or choices versus divisible amounts such as flows. This insight applies when keywords like 'whole units', 'integer quantities', or 'indivisible' appear in the problem statement. This insight applies when the problem statement includes keywords such as 'batches', 'discrete items', or 'whole numbers', indicating that the decision variables should be integers. For example, when the problem involves products or items that must be produced in whole numbers, such as 'reams of paper' or 'units of product'. This insight does NOT apply when the problem involves keywords like 'fractional', 'divisible', or 'flows', indicating that decision variables can logically take non-integer values.",
    "explanation": "When the problem involves decision variables representing integer quantities, the best practice is to define these variables as integer types. A common mistake is to define them as continuous variables, which happens because of overlooking the indivisible nature of the quantities. More generally, this reflects that proper variable definition must align with the intrinsic nature of the decision quantities being modeled.",
    "example": "# Wrong: Continuous variables\nx_i \u2265 0\n\n# Correct: Integer variables\nx_i \u2208 \\mathbb{Z}^+, \u2200i \u2208 P\n\n# Wrong: Continuous variables\nx1 = model.addVar(vtype=GRB.CONTINUOUS, name=\"Chicken\")\n\n# Correct: Integer variables\nx1 = model.addVar(vtype=GRB.INTEGER, name=\"Chicken\")",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E023",
      "E030",
      "E019",
      "E021",
      "E014"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [
        "A235",
        "B062",
        "F203",
        "F057",
        "F102",
        "F122",
        "F103",
        "A092",
        "B016",
        "B019",
        "B015",
        "B023",
        "B068",
        "F140",
        "B081",
        "B021",
        "E107"
      ],
      "negative": [
        "A171",
        "A180",
        "A176",
        "A223",
        "F080",
        "E107",
        "F021"
      ],
      "unretrieved": [
        "E025",
        "F083",
        "F021",
        "B066",
        "B031",
        "A033",
        "A179",
        "A092"
      ],
      "irrelevant": [
        "B080"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 6,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Incorrect Relational Operators"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires meeting or exceeding specific minimum requirements. For example, when the problem statement mentioned minimum nutritional intake targets for protein, carbohydrates, and calories, the constraints should ensure these requirements are met using greater than or equal to operators. This insight applies when keywords such as 'minimum', 'at least', or 'threshold' are used in describing requirements for production, inventory, or resource allocation. This insight does NOT apply when the problem description involves meeting exact market demands or specific units of demand without mention of minimum requirements. For example, when the problem statement mentions exact production levels to match market demand over several months without specifying minimum thresholds for production or inventory, the constraints should ensure exact demand matching rather than exceeding minimum requirements.",
    "explanation": "When the problem involves constraints that specify minimum requirements, the best practice is to use '\u2265' operators to reflect 'at least' conditions. A common mistake is to use incorrect relational operators like '=', which happens because the modeler might misinterpret the requirement as an exact match rather than a minimum threshold. More generally, this reflects the importance of accurately translating problem requirements into mathematical expressions.",
    "example": "# Wrong\nsum(protein[i] * x[i] for i in range(n)) > protein_req\n\n# Correct\nsum(protein[i] * x[i] for i in range(n)) >= protein_req",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E023",
      "E014"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [
        "A171",
        "B029",
        "A180",
        "E025",
        "F163",
        "F152",
        "A176",
        "A104",
        "F019",
        "F080",
        "A236",
        "A084",
        "B000",
        "E023",
        "E029",
        "E021",
        "E003",
        "E017",
        "E019",
        "E001",
        "E014",
        "E030",
        "E004",
        "E012",
        "E005",
        "E007",
        "E028",
        "E033",
        "E020",
        "E013",
        "E024",
        "E034",
        "A026",
        "A112",
        "A083",
        "A229",
        "F088",
        "F021",
        "E002",
        "E006",
        "E011",
        "E009",
        "B064"
      ],
      "negative": [
        "B066"
      ],
      "unretrieved": [],
      "irrelevant": [
        "F203",
        "F102",
        "B030"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 7,
    "taxonomy": {
      "General Formulation": {
        "Objective Specification": [
          "Redundant Auxiliary Variables"
        ]
      }
    },
    "condition": "This insight applies when the objective function can be directly expressed using existing terms without the need for additional variables. For example, in the failed model, the objective was to minimize cost using existing cost parameters and decision variables, but it didn't require any auxiliary variables.",
    "explanation": "When the problem involves minimizing or maximizing an expression already defined by existing parameters and variables, the best practice is to directly use these in the objective function. A common mistake is to introduce unnecessary auxiliary variables, which happens because the modeler may not recognize that the existing terms suffice. More generally, this reflects that objective specifications should be streamlined to avoid redundancy, thereby simplifying the model.",
    "example": "# Wrong\n# Introducing an auxiliary variable for total cost\nZ_aux = gp.quicksum(costs[i] * x[i] for i in costs)\nmodel.setObjective(Z_aux, GRB.MINIMIZE)\n\n# Correct\nmodel.setObjective(gp.quicksum(costs[i] * x[i] for i in costs), GRB.MINIMIZE)",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E021",
      "E030"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "F021",
        "B030",
        "B039",
        "B096",
        "B064"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 8,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem statement mentioned the need to balance the raw material contents in candy production to meet percentage requirements.\nThis insight applies when the problem involves the allocation, mixing, or redistribution of resources across stages or nodes, ensuring balance or conservation of specific components or resources. For example, when the problem statement mentions blending raw materials with specific content limitations or redistributing resources among multiple nodes.\nThis insight does NOT apply when the problem involves direct assignments without balance needs or when conservation or allocation considerations are absent, such as direct tasks that do not involve resource flow or transformation.",
    "explanation": "When the problem involves ensuring the balance of raw material content in each candy brand, the best practice is to explicitly model the resource allocation using balance equations that account for all raw materials. A common mistake is to omit these balance equations, which happens because the modeler incorrectly assumes that directly specifying percentage constraints suffices for balance. More generally, this reflects that proper resource allocation requires explicit equations to ensure conservation and satisfaction of all constraints.",
    "example": "# Wrong: Omitting resource balance equations.\n# Correct: Implementing resource balance equations such as R['RawA', 'CandyA'] + R['RawB', 'CandyA'] + R['RawC', 'CandyA'] == X['CandyA'].",
    "iteration": 0,
    "version": 1,
    "task_id": "B058",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "B096",
        "A186",
        "B030",
        "B039",
        "B000",
        "E038",
        "B031",
        "B015"
      ],
      "irrelevant": [
        "E107",
        "E035"
      ],
      "invalid": [
        "E107",
        "E038"
      ]
    }
  },
  {
    "insight_id": 9,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Incorrect Relational Operators"
        ]
      }
    },
    "condition": "This insight applies when natural-language statements such as 'at most' or 'at least' must be translated into algebraic inequalities. This insight applies when keywords such as 'at least', 'at most', 'minimum', or 'maximum' appear in the problem, indicating the need for algebraic inequality translation. This insight does NOT apply when the problem involves proportional constraints, allocation decisions, or probability-focused objectives that do not use these keywords.",
    "explanation": "When the problem involves translating percentage requirements into constraints, the best practice is to use the correct relational operators (\u2265, \u2264) that align with the problem's 'at least' or 'at most' intent. A common mistake is using unnecessary or incorrect constraints such as P_{ij} \u00b7 x_j \u2265 0.60 \u00b7 x_j, which happens because of a misinterpretation of the constraint requirements. More generally, this reflects that accurately translating problem constraints into algebraic form is crucial for model correctness.",
    "example": "# Wrong: P_{AA} \u00b7 x_A \u2265 0.60 \u00b7 x_A\n# Correct: R['RawA', 'CandyA'] >= 0.60 * X['CandyA']",
    "iteration": 0,
    "version": 1,
    "task_id": "B058",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B062",
        "A093",
        "A186",
        "B080",
        "A033",
        "F122",
        "B066"
      ],
      "negative": [
        "F203",
        "F057",
        "F122",
        "A026",
        "A186",
        "A229",
        "E107"
      ],
      "unretrieved": [
        "F163",
        "F103",
        "A083",
        "A092",
        "F102",
        "F140",
        "A093",
        "B015"
      ],
      "irrelevant": [
        "B029",
        "A235",
        "B096",
        "F152",
        "F102",
        "A240",
        "A104",
        "F019",
        "F021",
        "B016",
        "B019",
        "A236",
        "A084",
        "B066",
        "B064",
        "B039",
        "B023",
        "B000",
        "E023",
        "E029",
        "E021",
        "E003",
        "E019",
        "E001",
        "E014",
        "E004",
        "E012",
        "E005",
        "E007",
        "E028",
        "E020",
        "E013",
        "E024",
        "E034",
        "A179",
        "A172",
        "F091",
        "B062",
        "F103",
        "A112",
        "A083",
        "A092",
        "F088",
        "F167",
        "F126",
        "B080",
        "B081",
        "E002",
        "E006",
        "E011",
        "E009",
        "B031",
        "B030",
        "B049"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 10,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Indexing & Data Structure Alignment"
        ]
      }
    },
    "condition": "This insight applies when variables are indexed over sets or dictionaries that must align with the keys of the provided data. For example, when the problem statement mentioned using variables for candy brands and raw materials which need consistent indexing.",
    "explanation": "When the problem involves defining variables for indexed sets such as candy brands and raw materials, the best practice is to ensure alignment between variable indices and parameter keys. A common mistake is misaligning these indices, leading to errors or incorrect model formulations, which happens because of oversight or misunderstanding of data structure requirements. More generally, this reflects that proper indexing is essential for variable definition and model consistency.",
    "example": "# Wrong: Using inconsistent indices or variable names without alignment.\n# Correct: Defining variables and constraints with aligned indexing, such as using X[candy_brands] and R[raw_materials, candy_brands].",
    "iteration": 0,
    "version": 1,
    "task_id": "B058",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "B096",
        "B099",
        "E046"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 11,
    "taxonomy": {
      "General Formulation": {
        "Objective Specification": [
          "Redundant Auxiliary Variables"
        ]
      }
    },
    "condition": "This insight applies when auxiliary variables merely re-express existing linear combinations without adding modeling value. For example, in the diet optimization problem, using a direct summation in the objective function instead of introducing additional variables is more efficient.",
    "explanation": "When the problem involves minimizing or maximizing a sum of terms, the best practice is to directly express this in the objective function. A common mistake is to introduce unnecessary auxiliary variables, which happens because modelers might incorrectly believe these variables are needed to capture a linear combination. More generally, this reflects that direct expressions are preferable when they do not compromise clarity or solver performance.",
    "example": "# Wrong\nMinimize z = sum_i (auxiliary_variable_i)\n\n# Correct\nMinimize sum_i (cost_i * x_i)",
    "iteration": 0,
    "version": 1,
    "task_id": "E020",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "B081"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 12,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision quantities in the problem represent indivisible counts or choices versus divisible amounts such as flows. For example, when the problem statement mentioned the cost, protein, carbohydrate, and calorie content of food items per unit, and the gold-standard program used integer variables to represent the units of food items to be purchased. This insight applies when decision quantities in the problem represent indivisible counts or choices versus divisible amounts such as flows. For example, when the problem statement mentions servings of food items, which naturally involve discrete units, integer variables should be used to represent the number of servings to be purchased or consumed, or when indivisible items like paintings, sculptures, or vehicles must be allocated between parties. This insight does NOT apply when the problem context involves scenarios where items can be fractionally divided or shared, such as in shared resources or fractional ownership models.",
    "explanation": "When the problem involves purchasing items in discrete units, such as servings of food, the best practice is to use integer decision variables. A common mistake is to use continuous variables for such quantities, which happens because the decision maker might assume divisibility without considering that items are naturally counted in whole units. More generally, this reflects that modeling discrete choices or counts requires integer variables to ensure solutions are interpretable and feasible in real-world terms.",
    "example": "# Wrong\nx_i: continuous variable representing amount of food i\n\n# Correct\nx[f]: integer variable representing units of food f",
    "iteration": 0,
    "version": 1,
    "task_id": "E025",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "F203",
        "A092",
        "B032"
      ],
      "negative": [],
      "unretrieved": [
        "A092",
        "A223",
        "B032",
        "E019",
        "E005",
        "E028",
        "E033",
        "E025",
        "B081",
        "E011"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 13,
    "taxonomy": {
      "General Formulation": {
        "Objective Specification": [
          "Redundant Auxiliary Variables"
        ]
      }
    },
    "condition": "This insight applies when the objective function can be directly expressed in terms of given parameters and decision variables without the need for additional variables. For example, when the problem statement involves minimizing the total cost using the costs of food items and the failed mathematical model directly calculates the total cost without introducing unnecessary variables.",
    "explanation": "When the problem involves directly minimizing the total cost based on known item costs and decision variables, the best practice is to use the given parameters and decision variables directly in the objective function. A common mistake is introducing auxiliary variables to re-express these relationships, which happens because the modeler may believe it adds clarity or flexibility but it actually adds redundancy. More generally, this reflects that unnecessary variables can complicate models without providing any additional information or computational benefit.",
    "example": "# Wrong\nObjective: min z\nConstraints: z = sum(c_i * x_i for i in F)\n\n# Correct\nObjective: min sum(c_i * x_i for i in F)",
    "iteration": 0,
    "version": 1,
    "task_id": "E025",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "A093"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 14,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision quantities in the problem represent indivisible counts or choices versus divisible amounts such as flows. For example, when the problem statement mentioned the need to determine the most cost-effective way to meet dietary requirements using discrete units of food items (Chicken, Rice, Broccoli, Eggs).",
    "explanation": "When the problem involves selecting food items based on their nutritional content and cost, the best practice is to define the decision variables as integers if the items must be purchased in whole units. A common mistake is to define these variables as continuous, which happens because the modeler may overlook the indivisible nature of the items. More generally, this reflects that integer variables should be used in optimization models when dealing with discrete, countable items.",
    "example": "# Wrong: \n- x_chicken = model.addVar(vtype=GRB.CONTINUOUS, name='x_chicken')\n\n# Correct: \n- x_chicken = model.addVar(vtype=GRB.INTEGER, name='x_chicken')",
    "iteration": 0,
    "version": 1,
    "task_id": "E024",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 15,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision quantities in the problem represent indivisible counts or choices versus divisible amounts such as flows. For example, when the problem statement mentioned food items like Chicken, Rice, Broccoli, and Eggs must be selected in whole units.",
    "explanation": "When the problem involves selecting whole units of food items, the best practice is to use integer variables. A common mistake is defining these variables as continuous, which happens because the modeler overlooks the fact that partial units of food cannot be practically selected. More generally, this reflects that whenever a decision variable represents an indivisible count, it should be modeled as an integer.",
    "example": "# Wrong\nx_c = model.addVar(vtype=GRB.CONTINUOUS, name='x_c')\n\n# Correct\nx_c = model.addVar(vtype=GRB.INTEGER, name='x_c')",
    "iteration": 0,
    "version": 1,
    "task_id": "E024",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "F091"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 16,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Explicit Bounds"
        ]
      }
    },
    "condition": "This insight applies when the problem description provides natural physical, economic, or logical limits that can tightly bound decision variables. This insight applies when the problem involves decision variables representing quantities with natural or logical upper and lower bounds, such as those defined by capacity limits, budget constraints, or nutritional requirements. This insight does NOT apply when the problem involves decision variables without natural bounds, instead bounded by ratios or relationships between variables.",
    "explanation": "When the problem involves selecting quantities that have natural upper and lower bounds, such as quantities of food items, the best practice is to provide explicit bounds for decision variables. A common mistake is to omit these bounds, leading to unrealistic or excessive values, which happens because the modeler fails to incorporate known constraints on the quantities. More generally, this reflects that incorporating explicit bounds can improve model solvability and solution realism.",
    "example": "# Wrong\nx = model.addVars(8, lb=0)\n\n# Correct\nx = model.addVars(8, lb=0, ub=some_realistic_upper_bound)",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E024",
      "E020"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B096",
        "E025",
        "F167",
        "B015",
        "B049",
        "B081",
        "B021",
        "B039"
      ],
      "negative": [
        "A092",
        "A026",
        "F152",
        "B064"
      ],
      "unretrieved": [
        "B062",
        "E046",
        "E028",
        "A092"
      ],
      "irrelevant": [
        "A171",
        "B029",
        "F091",
        "F103",
        "A093",
        "A176",
        "A186",
        "B016",
        "F080",
        "B039",
        "E021",
        "E017",
        "E014",
        "E030",
        "E012",
        "E005",
        "E033",
        "E020",
        "B096",
        "E025",
        "E034",
        "F203",
        "F140",
        "A083",
        "A229",
        "A104",
        "F019",
        "F167",
        "F126",
        "E002",
        "E006",
        "E011",
        "A236",
        "A084",
        "E038"
      ],
      "invalid": [
        "F152",
        "B068",
        "E023",
        "B066",
        "B000"
      ]
    }
  },
  {
    "insight_id": 17,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Incorrect Relational Operators"
        ]
      }
    },
    "condition": "This insight applies when natural-language statements such as 'at most' or 'at least' must be translated into algebraic inequalities. This insight applies when both preference constraints and non-strictness are present, such as with phrases like 'the number of goat curry bowls must be larger than the number of chicken curry bowls'. This insight does NOT apply when the problem involves strict requirements explicitly stated as hard constraints. For example, when the problem statement mentions explicit minimum or maximum requirements that must be strictly met, such as 'at least 12 acres of potatoes' or 'at most twice the amount of cucumbers as potatoes'.",
    "explanation": "When the problem involves preference constraints that should not strictly enforce inequality, the best practice is to use non-strict inequalities like 'y >= x'. A common mistake is using strict inequalities such as 'y > x', which happens because the preference is misinterpreted as a hard constraint. More generally, this reflects that constraints derived from preferences should be inclusive unless specified otherwise.",
    "example": "# Wrong: y > x\n# Correct: y >= x",
    "iteration": 0,
    "version": 1,
    "task_id": "A026",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [
        "F163"
      ],
      "unretrieved": [
        "F152",
        "A026",
        "F203",
        "A083",
        "B019"
      ],
      "irrelevant": [
        "F167"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 18,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Strict Inequalities"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains strict inequality relations between variables that cannot be directly handled by LP/MIP solvers. For example, when the formulation included a constraint y > x, which is not supported directly by Gurobi.",
    "explanation": "When the problem involves modeling strict inequality constraints. The best practice is to convert strict inequalities into non-strict ones by adjusting the inequality appropriately, such as using y >= x + 1 for integer variables. A common mistake is to attempt to use strict inequalities directly, which happens because solvers like Gurobi do not support them natively. More generally, this reflects that strict inequalities need to be reformulated into equivalent non-strict inequalities in the context of integer programming.",
    "example": "# Wrong: model.addConstr(y > x, \"PreferenceCucumbers\")\n# Correct: model.addConstr(y >= x + 1, \"PreferenceCucumbers\")",
    "iteration": 0,
    "version": 1,
    "task_id": "A026",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 19,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves constraints on the usage of limited resources such as oven time and pastry chef time. For example, when the bakery problem specifies maximum available hours for oven and pastry chef time per day. This insight applies when the problem description involves constraints on limited resources like time, space, or machine capacity. For example, when the problem mentions maximum available length for parking, maximum hours for processing in workshops, or machine hours in a factory. This insight does NOT apply when the problem description involves dynamic or proportional constraints, such as materials directly proportional to production or workforce management and training. For example, when the problem statement mentions constraints on chemical compounds or involves hiring and scheduling workers.",
    "explanation": "When the problem involves resource constraints, the best practice is to ensure that these constraints accurately reflect the available resources. A common mistake is to incorrectly model the constraints, leading to infeasibility or suboptimal solutions, which happens because the constraints do not correctly capture the limitations set by the resources. More generally, this reflects that resource constraints must be precisely formulated to capture the actual limits and capacities of the resources involved in the problem.",
    "example": "# Wrong\n\\text{C1:} \\quad O_B \\cdot x_B + O_C \\cdot x_C \\leq H_O\n\\text{C2:} \\quad P_B \\cdot x_B + P_C \\cdot x_C \\leq H_P\n\n# Correct\n# Assuming the constraints are correctly formulated, as no syntax errors were identified.",
    "iteration": 0,
    "version": 1,
    "task_id": "A033",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "F169",
        "F192",
        "A223",
        "B087",
        "A236",
        "A084",
        "B066",
        "B031",
        "B064",
        "A033"
      ],
      "negative": [
        "F091",
        "B000"
      ],
      "unretrieved": [
        "B080",
        "B064",
        "B030"
      ],
      "irrelevant": [
        "F021"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 20,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Explicit Bounds"
        ]
      }
    },
    "condition": "This insight applies when the problem description provides natural physical, economic, or logical limits that can tightly bound decision variables. For example, the problem statement does not impose any explicit upper bounds on the number of batches of bagels or croissants, which could have been incorporated to reflect capacity limits.",
    "explanation": "When the problem involves decision variables with natural upper bounds, the best practice is to explicitly set these bounds to speed up the solving process and avoid unrealistic solutions. A common mistake is to omit these bounds, which happens because the modeler does not incorporate all known constraints. More generally, this reflects that adding explicit variable bounds when possible can enhance solver efficiency and result quality.",
    "example": "# Wrong\n# No explicit upper bounds on x_B and x_C\n\n# Correct\nmodel.addConstr(x <= max_bagels, 'MaxBagels')",
    "iteration": 0,
    "version": 1,
    "task_id": "A033",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 21,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision quantities in the problem represent indivisible counts or choices versus divisible amounts such as flows. For example, when the problem statement mentioned acres of land or the number of batches of bagels and croissants, which are typically divisible quantities, the failed mathematical model incorrectly defined them as integer variables.\nThis insight applies when both the divisibility of the quantity and a lack of explicit indivisibility requirement are present in the problem statement. For example, when the problem statement mentions quantities like hours or dollars, and there's no specific mention of whole number constraints.\nThis insight does NOT apply when decision quantities represent indivisible units of production or items that must be produced or utilized in whole numbers. For example, when the problem statement mentions batches of bagels and croissants which must be produced as whole units, the mathematical model correctly defines them as integer variables.",
    "explanation": "When the problem involves decision variables that are conceptually continuous, the best practice is to define them as continuous variables. A common mistake is defining them as integer variables, which happens because of an incorrect assumption that the decisions must be indivisible. More generally, this reflects that continuous quantities should be modeled with continuous variables unless explicitly required to be discrete.",
    "example": "# Wrong: x, y \u2208 \u2124\n# Correct: x, y \u2208 \u211d\n\n# Wrong\nx_B = number of batches of bagels, x_B \u2208 \u2124\u207a\n\n# Correct\nx = model.addVar(name='Bagels')",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "A033",
      "A026"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [
        "F169"
      ],
      "unretrieved": [],
      "irrelevant": [
        "F163",
        "F167"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 22,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem statement mentioned the maximum hours available for the meat slicer and meat packer, which are resources that must be allocated without exceeding their capacities.\nThis insight applies when the problem involves resource allocation through machines or processes over time, with strict capacity limits that must not be exceeded. For example, when the problem statement mentions the maximum hours available for the meat slicer and meat packer, which are machines that must operate within their annual capacity limits.\nThis insight does NOT apply when resources are unlimited or when there are no strict capacity constraints mentioned in the problem.",
    "explanation": "When the problem involves resource allocation, the best practice is to correctly define capacity constraints that ensure resources are not over-allocated. A common mistake is to miscalculate or misrepresent these constraints, which happens because the modeler may not align the constraints with the actual resource limits. More generally, this reflects that accurate capacity constraints are essential for valid resource allocation models.",
    "example": "# Wrong\n4 * x_h + 2 * x_r <= 4000\n\n# Correct\n4 * x_h + 2.5 * x_r <= 4000",
    "iteration": 0,
    "version": 1,
    "task_id": "A172",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B000"
      ],
      "negative": [],
      "unretrieved": [
        "A172"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 23,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Range Constraints"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains range constraints that need to be represented as two separate inequalities. For example, when the formulation included a constraint for the number of plush toys to be between 90 and 190.",
    "explanation": "When the problem involves specifying a variable within a specific range. The best practice is to split the range constraint into two separate inequality constraints. A common mistake is to try and implement a range constraint directly in one line, which happens because the syntax for such constraints is not supported in most optimization solvers. More generally, this reflects that complex constraints should be broken down into simpler, solver-recognizable components.",
    "example": "# Wrong: model.addConstr(L_p <= x_p <= U_p, \"PlushToysBounds\")\n# Correct: model.addConstr(x_p >= L_p, \"PlushToysLowerBound\")\n# Correct: model.addConstr(x_p <= U_p, \"PlushToysUpperBound\")",
    "iteration": 0,
    "version": 1,
    "task_id": "A178",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 24,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Strict Inequalities"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains logical conditions or constraints expressed as strict inequalities. For example, when the formulation included logical conditions like (x_A > 0), which are not directly supported by LP/MIP solvers.",
    "explanation": "When the problem involves logical constraints using strict inequalities. The best practice is to use indicator constraints or reformulate using non-strict inequalities. A common mistake is to attempt to directly implement strict inequalities in solvers, which happens because solvers do not natively support these as they do non-strict inequalities. More generally, this reflects that solvers require constraints to be expressed in a format they can handle, often requiring reformulation or the use of additional constructs like binary variables.",
    "example": "# Wrong: model.addConstr((x_A > 0).getAttr(GRB.Attr.LB) <= 2, \"MaxTwoFruits\")\n# Correct: model.addGenConstrIndicator(y_A, True, x_A >= 0.0001)",
    "iteration": 0,
    "version": 1,
    "task_id": "B057",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 25,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision points in the problem involve selecting a limited number of options or making yes/no decisions, or when decision quantities represent indivisible counts versus divisible amounts. For example, when the problem statement mentioned that Vicky and David are unwilling to grow more than two types of fruit or when it referred to the number of batches of hams and pork ribs to produce.",
    "explanation": "When the problem involves selecting a limited number of options or deciding on discrete quantities, the best practice is to use binary or integer variables to represent these choices. A common mistake is to use non-binary or continuous variables without explicit selection constraints, which happens because the model fails to capture the discrete nature of these decisions. More generally, this reflects that decision variables should align with the physical or logical nature of the quantities they represent.",
    "example": "# Wrong: (x_A > 0) + (x_P > 0) + (x_O > 0) + (x_L > 0) <= 2\n# Correct: y_A + y_P + y_O + y_L <= 2, with y_A, y_P, y_O, y_L as binary variables\n# Wrong: x_A, x_P, x_O, x_L as continuous variables only\n# Correct: y_A, y_P, y_O, y_L as binary variables to capture planting decisions\n# Wrong: x_h \\in \\mathbb{Z}_+ \\quad \\text{(Number of batches of hams to produce)}\n# Correct: x_h \\in \\mathbb{R}_+ \\quad \\text{(Number of batches of hams to produce)}",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "A172",
      "B057"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [
        "F083"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 26,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Incorrect Relational Operators"
        ]
      }
    },
    "condition": "This insight applies when natural-language statements such as 'at most' or 'at least' must be translated into algebraic inequalities. For example, when the problem description mentioned using 'at most' 70 hours of oven time and 32 hours of pastry chef time.",
    "explanation": "When the problem involves constraints expressed with 'at most', the best practice is to use '\u2264' in the mathematical formulation. A common mistake is to use incorrect relational operators, which happens because the modeler might misinterpret the natural language description. More generally, this reflects that careful attention to language translation is essential in constraint formulation.",
    "example": "# Wrong\n2x_B + 1x_C < 70\n\n# Correct\n2x_B + 1x_C \u2264 70",
    "iteration": 0,
    "version": 1,
    "task_id": "F169",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "F169",
        "A033"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 27,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem description involves managing oven and pastry chef hours as resources that must be allocated to maximize profit.",
    "explanation": "When the problem involves allocating limited resources to different tasks, the best practice is to formulate constraints that ensure the total resource usage does not exceed available limits. A common mistake is to misformulate these constraints, leading to infeasibility or suboptimal solutions. More generally, this reflects that accurately capturing resource constraints is crucial for valid and effective optimization models.",
    "example": "# Wrong\n2 \\cdot x_B + 1 \\cdot x_C > 70 \n\n# Correct\n2 \\cdot x_B + 1 \\cdot x_C \\leq 70",
    "iteration": 0,
    "version": 1,
    "task_id": "F169",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 28,
    "taxonomy": {
      "General Formulation": {
        "Explicit Bounds": []
      }
    },
    "condition": "This insight applies when the problem description provides natural physical, economic, or logical limits that can tightly bound decision variables. For example, when the problem statement mentioned the total available oven and pastry chef hours, which define natural upper limits for the number of batches.",
    "explanation": "When the problem involves resource constraints, the best practice is to set explicit bounds on decision variables to reflect these limits. A common mistake is to leave bounds implicit, which happens because the modeler assumes constraints inherently enforce these limits. More generally, this reflects that explicit bounds can improve solver efficiency and prevent solutions from violating implicit assumptions.",
    "example": "# Wrong\nx_B, x_C \\geq 0\n\n# Correct\n0 \\leq x_B, x_C \\leq \\min(\\frac{H_O}{O_B}, \\frac{H_P}{P_C})",
    "iteration": 0,
    "version": 1,
    "task_id": "F169",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 29,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem statement involves using machines with limited hours to produce batches of products.",
    "explanation": "When the problem involves balancing the use of limited resources like machine hours, the best practice is to ensure that all constraints accurately reflect these limits. A common mistake is to misrepresent these constraints, which happens because the model might not properly account for the total available resource capacity. More generally, this reflects that resource constraints must precisely align with the actual resource limits to ensure feasible solutions.",
    "example": "# Wrong\n4x_h + 2x_r = 4000\n# Correct\n4x_h + 2x_r <= 4000",
    "iteration": 0,
    "version": 1,
    "task_id": "F083",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "A104",
        "F019",
        "B087",
        "B030",
        "B031",
        "A179"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [
        "F083",
        "B064",
        "B000"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 30,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Incorrect Relational Operators"
        ]
      }
    },
    "condition": "This insight applies when natural-language statements such as 'at most' or 'at least' must be translated into algebraic inequalities. For example, when the problem statement mentioned that each machine runs for at most 4000 hours per year, which implies using '\u2264' in the constraints.\nThis insight applies when natural-language statements such as 'at most', 'at least', or 'exactly one' must be translated into algebraic inequalities or logical expressions. For example, when the problem statement mentions that the total pollution generated must not exceed 1000 units, which implies using '\u2264' in the constraints, or when it mentions that only one of two transportation methods can be chosen, which implies using a logical constraint like a binary decision variable selection.\nThis insight does NOT apply when the problem involves qualitative factors that are not easily translated into quantitative constraints or when the problem requires a different form of expression such as equalities or non-standard operators.",
    "explanation": "When the problem involves capacity constraints stated as 'at most', the best practice is to use the '\u2264' operator to translate this into mathematical form. A common mistake is using '\u2265' or a different operator, which happens because of misinterpretation of the constraint direction. More generally, this reflects that translating verbal constraints into mathematical form requires careful alignment of relational operators with their intended meaning.",
    "example": "# Wrong\n4x_h + 2x_r >= 4000  # Incorrect direction\n# Correct\n4x_h + 2x_r <= 4000  # Correct direction",
    "iteration": 0,
    "version": 1,
    "task_id": "F083",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "F083",
        "A093",
        "B030",
        "B064",
        "A172",
        "B062",
        "B066"
      ],
      "negative": [],
      "unretrieved": [
        "B062"
      ],
      "irrelevant": [
        "B000"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 31,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Explicit Bounds"
        ]
      }
    },
    "condition": "This insight applies when the problem description provides natural physical, economic, or logical limits that can tightly bound decision variables. For example, when the problem statement mentioned that each machine runs for at most 4000 hours per year, limiting the production of batches.",
    "explanation": "When the problem involves bounded resources, the best practice is to set explicit bounds on decision variables that reflect these limits. A common mistake is to omit these bounds, which happens because of an oversight of resource constraints. More generally, this reflects that explicit bounds help improve model tractability and solution quality.",
    "example": "# Wrong\nx_h \\in \\mathbb{R}_+  # No explicit bounds\n\n# Correct\nx_H = model.addVar(vtype=GRB.INTEGER, lb=0, ub=T_S/t_SH, name='x_H')",
    "iteration": 0,
    "version": 1,
    "task_id": "F083",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B049"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [
        "F163",
        "B066",
        "B030"
      ],
      "invalid": [
        "F083",
        "B030",
        "A172"
      ]
    }
  },
  {
    "insight_id": 32,
    "taxonomy": {
      "General Formulation": {
        "Objective Specification": [
          "Redundant Auxiliary Variables"
        ]
      }
    },
    "condition": "This insight applies when auxiliary variables merely re-express existing linear combinations without adding modeling value. For example, when the failed model uses redundant expressions in the objective function.",
    "explanation": "When the problem involves a straightforward objective function, the best practice is to use the simplest expression possible. A common mistake is introducing unnecessary complexity through redundant variables or expressions, which happens because the modeler may overcomplicate the formulation. More generally, this reflects that simpler formulations are easier to solve and understand, reducing the likelihood of errors.",
    "example": "# Wrong: Z = T_c * x_c + T_b * x_b\n# Correct: Use the existing variables directly in the objective",
    "iteration": 0,
    "version": 1,
    "task_id": "A146",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 33,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Linearization of Non-linear Forms"
        ]
      }
    },
    "condition": "This insight applies when the problem description includes constraints that involve non-linear relationships between decision variables. For example, when the problem statement mentioned a maximum proportion of total transport by trolleys, and the failed model used a non-linear constraint to express this proportion.",
    "explanation": "When the problem involves constraints that have non-linear expressions, the best practice is to linearize them to ensure tractability and solver performance. A common mistake is to directly use non-linear forms in a linear programming model, which happens because non-linear constraints cannot be handled by linear solvers directly. More generally, this reflects that non-linear expressions must be transformed into linear equivalents in linear optimization models.",
    "example": "# Wrong: 7x_t / (5x_c + 7x_t) <= 0.4\n# Correct: 2x_c >= 4.2x_t",
    "iteration": 0,
    "version": 1,
    "task_id": "A198",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "B096",
        "F057",
        "F102",
        "A186",
        "B016",
        "B032"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 34,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Explicit Bounds"
        ]
      }
    },
    "condition": "This insight applies when the problem description provides natural physical, economic, or logical limits that can tightly bound decision variables. For example, when the problem statement mentioned a minimum of 12 trolleys to be used.",
    "explanation": "When the problem involves decision variables with known bounds, the best practice is to explicitly set these bounds to improve model performance and accuracy. A common mistake is to overlook these bounds, such as not enforcing a lower bound on the number of trolleys, which can lead to solutions that violate problem constraints. More generally, this reflects that explicit bounds should be used to prevent infeasible solutions and improve solver efficiency.",
    "example": "# Wrong: x_t \\in \\mathbb{Z}^+ \n# Correct: x_t \\geq t_{\\text{min}}",
    "iteration": 0,
    "version": 1,
    "task_id": "A198",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "F102"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 35,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Resource Pooling"
        ]
      }
    },
    "condition": "This insight applies when the problem domain contains multiple identical resources that are substitutable and individual identities do not matter. For example, when the problem statement described using trolleys and carts interchangeably to meet a total delivery rate.",
    "explanation": "When the problem involves interchangeable resources, the best practice is to aggregate them into a single pool for allocation. A common mistake is treating them as distinct without recognizing their interchangeability, which happens because the modeler fails to consolidate resources that can be pooled. More generally, this reflects that resource pooling can simplify models by reducing the number of decision variables and constraints.",
    "example": "# Wrong: Treat resources separately without pooling \n# Correct: Aggregate resources into a single delivery capacity constraint",
    "iteration": 0,
    "version": 1,
    "task_id": "A198",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 36,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves balancing resource supply and demand to meet a specific target, or when there is a need to balance or meet specific delivery rates using multiple resource types. For example, when the problem statement mentioned transporting a fixed number of items using different modes of transportation with specific capacities.\nThis insight applies when the problem description involves both allocating resources with limited availability across multiple tasks and managing inventory levels while optimizing for a financial objective. For example, when the problem statement mentions maximizing production output using limited resources and ensuring warehouse capacity is not exceeded to maximize total revenue.\nThis insight does NOT apply when the problem description involves redistributing resources to exactly meet specific demands across multiple locations, where the total available resources match the total required resources. For example, when the problem statement mentions redistributing stock among warehouses to exactly meet each warehouse's specific needs.",
    "explanation": "When the problem involves transporting a fixed amount of items or setting a minimum requirement for resource allocation, the best practice is to use an inequality constraint to account for surplus or to ensure that the equations correctly reflect the total required delivery capacity. A common mistake is using an equality constraint, which happens because it may be incorrectly assumed that all resources must be fully utilized to meet the exact demand, or assuming a perfect balance without considering excess capacity. More generally, this reflects that capacity/resource balance equations should ensure feasibility without unnecessarily restricting solutions.",
    "example": "# Wrong: B_c * x_b + C_c * x_c = C\n# Correct: B_c * x_b + C_c * x_c >= C\n# Wrong: 5x_c + 7x_t = 100\n# Correct: 5x_c + 7x_t >= 100",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "A198",
      "A146"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [
        "F102"
      ],
      "negative": [
        "E107",
        "E035"
      ],
      "unretrieved": [
        "B031",
        "B049"
      ],
      "irrelevant": [
        "E038",
        "E035"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 37,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Explicit Bounds"
        ]
      }
    },
    "condition": "This insight applies when the problem description provides natural physical, economic, or logical limits that can tightly bound decision variables. For example, when the problem statement mentioned that there can be at most 5 helicopter trips, it requires setting an explicit upper bound for the decision variable representing helicopter trips.",
    "explanation": "When the problem involves decision variables that have natural bounds, the best practice is to explicitly set these bounds in the model. A common mistake is omitting these bounds, which happens because the model fails to incorporate known logical or physical limits. More generally, this reflects that setting explicit bounds can improve model efficiency and prevent infeasible solutions.",
    "example": "# Wrong: x_H <= H_max as a separate constraint\n# Correct: h = m.addVar(vtype=GRB.INTEGER, name='helicopter_trips', lb=0, ub=5)",
    "iteration": 0,
    "version": 1,
    "task_id": "A156",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B049"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 38,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Incorrect Relational Operators"
        ]
      }
    },
    "condition": "This insight applies when natural-language statements such as 'at least' or 'at most' must be translated into algebraic inequalities, and when constraints related to percentages might result in nonlinear relations. For example, when the problem statement mentioned 'at least 70% of delivery shifts must be by cart' or 'at least 60% of the trips should be by car,' potentially leading to nonlinear constraints. This insight applies when translating percentage-based constraints into algebraic inequalities introduces the possibility of nonlinear formulations that require linearization. For example, when the problem statement mentions that 'at least 30% of tons of candles must be transported through air,' which could lead to nonlinear constraints needing linearization. This insight does NOT apply when percentage-based constraints are already linear in nature and do not require linearization. For example, when the problem statement mentions a percentage of trips but the number of trips is an integer variable, and the percentage constraint is linear, such as 'at least 60% of the trips must be by car,' which directly translates into a simple linear inequality without additional linearization.",
    "explanation": "When the problem involves translating natural-language constraints or percentage requirements into mathematical expressions, the best practice is to ensure the correct relational operator is used and to linearize any nonlinear constraints. A common mistake is using an incorrect operator or leaving constraints in a nonlinear form, which happens because the algebraic form does not accurately reflect the qualitative constraint or the potential for linearization is not recognized. More generally, this reflects that precise translation and linearization of problem statements into mathematical constraints are essential for model accuracy and efficiency.",
    "example": "# Wrong: x_C >= R_C * (x_H + x_C) / (1 - R_C)\n# Correct: x_C >= 1.5 * x_H\n# Wrong: x_c \\geq 0.7 \\cdot (x_c + x_h)\n# Correct: x_c \\geq (7/3) \\cdot x_h\n# Wrong: x_c >= (P_c * (x_b + x_c)) / (1 - P_c)\n# Correct: 2 * x_c >= 3 * x_b",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "A136",
      "A211",
      "A156"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [
        "F057"
      ],
      "unretrieved": [
        "F122"
      ],
      "irrelevant": [
        "F102"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 39,
    "taxonomy": {
      "General Formulation": {
        "Objective Specification": [
          "Redundant Auxiliary Variables"
        ]
      }
    },
    "condition": "This insight applies when the problem description does not specify an objective function or when the objective function is incorrectly defined. For example, when the failed mathematical model has an objective to minimize zero, indicating no meaningful optimization target.",
    "explanation": "When the problem involves transporting goods with constraints on pollution and minimum trips, the best practice is to minimize a relevant objective, such as pollution. A common mistake is specifying a zero objective, which happens because the model lacks a meaningful goal to optimize. More generally, this reflects that optimization models should have clearly defined objectives that align with the problem's goals.",
    "example": "# Wrong: Minimize: 0\n# Correct: Minimize: pollution_horse * x_H",
    "iteration": 0,
    "version": 1,
    "task_id": "B062",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "B096",
        "F163",
        "B062",
        "B087",
        "B023",
        "E005",
        "F019",
        "B049"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 40,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Big-M & Indicator Variables"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves selecting between mutually exclusive options using binary variables. For example, when the failed mathematical model uses a big-M approach to link the choice of bicycle or handcart to their respective trip counts without effectively defining or utilizing M.\nThis insight applies when the problem description involves selecting between mutually exclusive options using binary variables, particularly when exclusivity impacts resource allocation or selection constraints. For example, when the problem involves manufacturing one type of toy (robots) that excludes another type (dolls) or leasing different types of stores within specified limits.\nThis insight does NOT apply when the problem involves selecting from more than two options or when additional constraints dictate specific selections beyond simple mutual exclusivity, such as dependencies among decisions, hierarchical constraints, or non-binary exclusive situations.",
    "explanation": "When the problem involves selecting between a bicycle or a handcart, with constraints on trips, the best practice is to use a well-defined big-M value to appropriately link binary choice variables to trip counts. A common mistake is not defining M correctly or using it ineffectively, which happens because of the failure to relate binary choices to their corresponding integer variables. More generally, this reflects that big-M values should be carefully calculated to maintain logical consistency in models involving binary decisions.",
    "example": "# Wrong: x_b \\leq M \\cdot y_b; M = \\lceil \\frac{U}{\\min(c_b, c_c)} \\rceil\n# Correct: x_b \\leq M \\cdot y_b; M = 1000",
    "iteration": 0,
    "version": 1,
    "task_id": "B062",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B062"
      ],
      "negative": [
        "B062",
        "B023",
        "B019",
        "B021"
      ],
      "unretrieved": [
        "B019",
        "B081"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 41,
    "taxonomy": {
      "General Formulation": {
        "Objective Specification": [
          "Redundant Auxiliary Variables"
        ]
      }
    },
    "condition": "This insight applies when auxiliary variables merely re-express existing linear combinations without adding modeling value. For example, when the failed model minimizes total trips rather than pollution, despite pollution being the relevant objective.",
    "explanation": "When the problem involves optimizing a specific objective, auxiliary variables should not re-express objectives that do not align with the problem's goals. The best practice is to directly optimize the relevant objective, here minimizing pollution. A common mistake is using an objective that is not aligned with the problem requirements, which happens because of misunderstanding the goal of the optimization task. More generally, this reflects that the objective function should directly target the primary goal stated in the problem.",
    "example": "# Wrong: Minimize total trips (x_horse + x_bicycle + x_handcart).\n# Correct: Minimize pollution_horse * x_H.",
    "iteration": 0,
    "version": 1,
    "task_id": "B062",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 42,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Incorrect Relational Operators"
        ]
      }
    },
    "condition": "This insight applies when natural-language statements such as 'at most' or 'at least' must be translated into algebraic inequalities. This insight applies when constraints involve thresholds and limits that must be respected, such as when the problem statement mentions 'the total amount of pollution generated by all trips must not exceed 1000 units' or 'at least 8 trips must be made using the horse'. This insight does NOT apply when constraints are not expressed in terms of inequalities or when the relational operators are irrelevant to the problem statement.",
    "explanation": "When the problem involves constraints that set a maximum or minimum threshold. The best practice is to use '\u2264' for 'at most' and '\u2265' for 'at least' conditions. A common mistake is using an incorrect relational operator, which happens because the modeler misinterprets the problem's constraints. More generally, this reflects that constraints must accurately represent the problem's conditions using the correct inequalities.",
    "example": "# Wrong: Pollution constraint as equality.\n# Correct: Pollution constraint as inequality: pollution_horse * x_H <= pollution_limit.",
    "iteration": 0,
    "version": 1,
    "task_id": "B062",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B062"
      ],
      "negative": [],
      "unretrieved": [
        "B062"
      ],
      "irrelevant": [
        "B023"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 43,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision quantities in the problem represent indivisible counts or choices versus divisible amounts such as flows. For example, when the problem statement mentioned the number of runner or canoe trips, which are discrete decisions.",
    "explanation": "When the problem involves discrete decisions, the best practice is to define variables as integers to reflect the indivisible nature of the decision. A common mistake is defining such variables as continuous, which happens because of oversight or misinterpretation of the problem constraints. More generally, this reflects that understanding the nature of decision variables (discrete vs. continuous) is essential for accurate modeling.",
    "example": "# Wrong: x = model.addVar(vtype=GRB.CONTINUOUS, name=\"runners\")\n# Correct: x = model.addVar(vtype=GRB.INTEGER, name=\"runners\")",
    "iteration": 0,
    "version": 1,
    "task_id": "F135",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 44,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem statement involves balancing the use of runners and canoers within a limited number of total hours.",
    "explanation": "When the problem involves resource allocation with constraints on total capacity, the best practice is to accurately represent the balance of resources across constraints. A common mistake is to overlook the interaction between resources, which happens because the constraints might not explicitly capture how different types of resources share a common capacity. More generally, this reflects that accurate modeling of resource interactions is essential to ensure feasibility and optimality.",
    "example": "# Wrong: 4 * x_R + 2 * x_C = 200  # Misinterpreting constraint as equality\n# Correct: 4 * x_R + 2 * x_C \u2264 200  # Correct representation as inequality",
    "iteration": 0,
    "version": 1,
    "task_id": "F135",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [
        "B030"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 45,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Incorrect Relational Operators"
        ]
      }
    },
    "condition": "This insight applies when natural-language statements such as 'at most' or 'at least' must be translated into algebraic inequalities. For example, when the problem statement mentioned that at most 33% of deliveries can be by canoe.",
    "explanation": "When the problem involves constraints that express proportions or limits, the best practice is to use the correct operator (\u2264, \u2265) to mirror the 'at most' or 'at least' conditions. A common mistake is using incorrect or inverted operators, which happens because of misunderstanding the natural language into algebraic representation. More generally, this reflects that precise translation of problem requirements into mathematical constraints is crucial for correct model formulation.",
    "example": "# Wrong: model.addConstr(y <= Pc * x) # This does not correctly represent the percentage constraint\n# Correct: model.addConstr(y <= Pc * (x + y)) # Correctly reflects the maximum percentage constraint\n# Wrong: 2 * x_C \u2264 x_R  # Incorrect simplification of delivery proportion constraint\n# Correct: x_C \u2264 0.33 * (x_R + x_C)  # Correct representation of the constraint",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "F135"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 46,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Incorrect Relational Operators"
        ]
      }
    },
    "condition": "This insight applies when decision variables or constraints need to accurately reflect the nature of the problem, whether in terms of continuous vs. discrete representations or using appropriate relational operators. This insight applies when there is a need to correctly represent decision variables or constraints in a way that aligns with the problem's intended flexibility or bounds. For example, when the problem statement involves minimum or maximum limits on chemical usage and proportion constraints between different types of chemicals. This insight does NOT apply when variables or constraints are inherently fixed and do not require flexibility, such as when dealing with absolute, deterministic values or explicitly defined constants.",
    "explanation": "When the problem involves decision quantities or constraints, the best practice is to ensure that variables are defined within appropriate bounds (e.g., [0, 1] for proportions) and constraints reflect the intended flexibility or limits (e.g., using inequalities for resource usage). A common mistake is treating these quantities as absolute amounts or using equality constraints, which happens because modelers misinterpret the intended representation or limits. More generally, this reflects that both decision variables and constraints must be defined to accurately capture the essence and intent expressed in the problem context.",
    "example": "# Wrong: x_H, x_V \u2208 [0, 100]; x_H + x_V = 100\n# Correct: x_H, x_V \u2208 [0, 1]; x_H + x_V <= 100",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "F209"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "A083"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 47,
    "taxonomy": {
      "General Formulation": {
        "Objective Specification": [
          "Sum vs. Makespan Confusion"
        ]
      }
    },
    "condition": "This insight applies when multiple resources or activities can run in parallel and the objective is ambiguous between total completion time and makespan. For example, when the problem statement mentioned minimizing the time it takes for the mixed bread to be ready, involving different times for chemicals A and B to become effective. This insight applies when the goal is to minimize the total time to readiness for parallel components, each with different effectiveness times. For example, when the problem statement involves adding different quantities of fertilizer and seeds to a lawn, each with its own time to become effective, and the objective is to minimize the overall time it takes for the lawn to be ready. This insight does NOT apply when the problem involves a single process or a sequence where makespan minimization is clearly stated. For example, when the problem statement mentions scheduling operations for fabric dyeing in a sequence of vats to minimize the completion time of the last batch, where each batch goes through a series of steps in a specific order.",
    "explanation": "When the problem involves minimizing the time for a mixture to be ready, the best practice is to minimize the weighted sum of times it takes each component to be effective. A common mistake is to interpret this as minimizing the makespan, which happens because makespan focuses on the maximum time any component takes to complete. More generally, this reflects that distinguishing between total completion time and makespan is crucial in parallel processing scenarios.",
    "example": "# Wrong\n\\text{Minimize} \\quad T = \\max(t_A \\cdot x_A, t_B \\cdot x_B)\n\n# Correct\n\\text{Minimize} \\quad T = t_A \\cdot x_A + t_B \\cdot x_B",
    "iteration": 0,
    "version": 1,
    "task_id": "A240",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "A093",
        "B034",
        "A236"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 48,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Incorrect Relational Operators"
        ]
      }
    },
    "condition": "This insight applies when natural-language statements such as 'at most' or 'at least' must be translated into algebraic inequalities. For example, when the problem statement mentioned 'at most a third as much chemical A as chemical B' and 'at least 300 units of chemical A'. This insight applies when comparative terms and numeric values are specifically used to define relational constraints in an optimization problem. This insight does NOT apply when the problem involves constraints that require additional inequalities not strictly relational or comparative, such as total quantities or time constraints.",
    "explanation": "When the problem involves translating constraints from natural language to algebraic form, the best practice is to use the correct relational operators that match the 'at most' or 'at least' intent. A common mistake is using incorrect operators, which happens because of misunderstanding the translation of qualitative constraints into quantitative form. More generally, this reflects that accurate translation of relational constraints is essential for correct mathematical modeling.",
    "example": "# Wrong\nx_A \\leq \\alpha \\cdot x_B \nx_A \\geq A_{\\text{min}}\n\n# Correct\nx_A \\leq \\alpha \\cdot x_B \nx_A \\geq A_{\\text{min}}",
    "iteration": 0,
    "version": 1,
    "task_id": "A240",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "A240"
      ],
      "negative": [
        "A083"
      ],
      "unretrieved": [],
      "irrelevant": [
        "B000"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 49,
    "taxonomy": {
      "Domain Modeling": {
        "Balancing": [
          "Load Balancing Constraints"
        ]
      }
    },
    "condition": "This insight applies when the problem requires balancing resources such that one type does not excessively outweigh another. For example, in the problem statement, the amount of fertilizer should not exceed twice the amount of seeds, ensuring a balanced application.",
    "explanation": "When the problem involves applying different resources, the best practice is to maintain a balance as specified by the constraints. A common mistake is to ignore or improperly implement these constraints, which happens because the modeller focuses only on individual resource limits rather than their relationship. More generally, this reflects that balancing constraints are crucial for maintaining proportionality between different resources.",
    "example": "# Wrong: x_f \u2264 2x_s (forgotten or ignored)\n# Correct: Add balancing constraint x_f \u2264 2x_s",
    "iteration": 0,
    "version": 1,
    "task_id": "A093",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 50,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision quantities in the problem represent indivisible counts or choices versus divisible amounts such as flows. For example, when the problem statement involves determining the number of units of sulfate and ginger, which should be integer values. This insight applies when decision quantities involve indivisible counts like trips or units, such as determining the number of bus trips to transport items. This insight does NOT apply when decision quantities are divisible and continuous, such as liquid volumes or electrical flows, where integer constraints would misrepresent the problem.",
    "explanation": "When the problem involves indivisible items or counts, the best practice is to use integer decision variables. A common mistake is using continuous variables, which happens because the modeler overlooks the discrete nature of the quantities involved. More generally, this reflects that decision variables should match the granularity and nature of the quantities they represent.",
    "example": "# Wrong\nS \\in \\mathbb{R}^+ \\quad \\text{(units of sulfate)}\nG \\in \\mathbb{R}^+ \\quad \\text{(units of ginger)}\n\n# Correct\nS \\in \\mathbb{Z}^+ \\quad \\text{(units of sulfate)}\nG \\in \\mathbb{Z}^+ \\quad \\text{(units of ginger)}",
    "iteration": 0,
    "version": 1,
    "task_id": "A112",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "F057",
        "B062",
        "F102",
        "B016"
      ],
      "negative": [],
      "unretrieved": [
        "F057",
        "A112"
      ],
      "irrelevant": [],
      "invalid": [
        "F126"
      ]
    }
  },
  {
    "insight_id": 51,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Explicit Bounds"
        ]
      }
    },
    "condition": "This insight applies when the problem description provides natural physical, economic, or logical limits that can tightly bound decision variables. For example, when the problem statement specifies a minimum and a maximum relationship for sulfate and ginger quantities.",
    "explanation": "When the problem involves decision variables with natural bounds, the best practice is to explicitly set these bounds to improve solver efficiency and prevent infeasible solutions. A common mistake is omitting these bounds, which happens because the modeler assumes the constraints alone will suffice. More generally, this reflects the importance of incorporating all known limits into the model to guide the solver effectively.",
    "example": "# Wrong\n# Variables without explicit bounds\nS = m.addVar(name=\"S\", vtype=GRB.INTEGER)\nG = m.addVar(name=\"G\", vtype=GRB.INTEGER)\n\n# Correct\n# Variables with explicit lower and upper bounds\nS = m.addVar(name=\"S\", lb=100, ub=267, vtype=GRB.INTEGER)\nG = m.addVar(name=\"G\", lb=0, ub=200, vtype=GRB.INTEGER)",
    "iteration": 0,
    "version": 1,
    "task_id": "A112",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "E025",
        "F167",
        "B064",
        "B039",
        "A092",
        "B081"
      ],
      "negative": [
        "A092",
        "A026",
        "F152",
        "B064"
      ],
      "unretrieved": [],
      "irrelevant": [
        "B096",
        "F163",
        "F091",
        "B062",
        "F057",
        "F102",
        "F103",
        "A093",
        "A083",
        "F021",
        "F192",
        "A223",
        "B016",
        "A236",
        "B066",
        "B031",
        "B023",
        "B000",
        "E025",
        "E034",
        "F126"
      ],
      "invalid": [
        "F152",
        "B030",
        "A112",
        "B066",
        "B000"
      ]
    }
  },
  {
    "insight_id": 52,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Resource Pooling"
        ]
      }
    },
    "condition": "This insight applies when a problem involves multiple resources that can perform similar tasks, and the individual identity of resources does not matter. For example, when the problem statement allows both companies to annotate images, and the solution needs to allocate the workload efficiently without distinguishing between individual images.",
    "explanation": "When the problem involves allocating tasks between resources that can perform similar functions, the best practice is to treat them as a pooled resource to optimize the allocation. A common mistake is modeling each resource separately without considering their interchangeable nature, which happens because the modeler may incorrectly assume distinct resource identities are necessary. More generally, this reflects that interchangeable resources should be pooled to simplify models and optimize allocations.",
    "example": "# Wrong: Treating resources separately without pooling\nx_s = specialized_hours\nx_c = common_hours\n\n# Correct: Pooled resource allocation\nx = specialized_images\ny = common_images",
    "iteration": 0,
    "version": 1,
    "task_id": "A229",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "B016"
      ],
      "irrelevant": [
        "B000"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 53,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision variables in the problem can represent both indivisible counts and divisible amounts. For example, when the failed model defines hours of work, which are divisible, but the gold-standard model defines the number of images annotated, which can be treated as a continuous flow for optimization purposes.",
    "explanation": "When the problem involves decision variables that can be modeled as continuous flows, the best practice is to use continuous variables to capture divisible quantities. A common mistake is using discrete variables unnecessarily, which happens because the modeler may misinterpret the nature of the quantities involved. More generally, this reflects that continuous variables should be used for divisible resources to improve model tractability and solver performance.",
    "example": "# Wrong: Using integer variables for hours\nx_s = int\nx_c = int\n\n# Correct: Using continuous variables for images\nx = float\ny = float",
    "iteration": 0,
    "version": 1,
    "task_id": "A229",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 54,
    "taxonomy": {
      "General Formulation": {
        "Objective Specification": [
          "Redundant Auxiliary Variables"
        ]
      }
    },
    "condition": "This insight applies when an optimization problem's objective function redundantly uses auxiliary variables that can be expressed directly. For example, when the failed mathematical model used an unnecessary transformation of payout rates in the objective function by defining it as (1 + r - p)\u00b7x, instead of directly using the correct expected payout coefficients.",
    "explanation": "When the problem involves maximizing expected payouts, the best practice is to directly use the expected payout rates in the objective function. A common mistake is redefining these rates with unnecessary transformations, which happens because of a misunderstanding of the payout conditions. More generally, this reflects that auxiliary variables should only be used when they add clarity or necessary structure to the model.",
    "example": "# Wrong: Maximize Z = (1 + r_B - p_B) * x_B + (1 + r_H - p_H) * x_H + (1 + r_S - p_S) * x_S\n# Correct: Maximize Z = 0.6 * x_B + 0.375 * x_H + 0.09 * x_S",
    "iteration": 0,
    "version": 1,
    "task_id": "A186",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "A186"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 55,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Objective Function Misalignment"
        ]
      }
    },
    "condition": "This insight applies when the problem description specifies optimizing for an average payout based on specific probabilities and returns. For example, when the problem statement mentioned maximizing average payout while considering different probabilities of losing money and payout ratios.",
    "explanation": "When the problem involves optimizing based on specific risk and return criteria, the best practice is to accurately translate these criteria into the objective function. A common mistake is to misrepresent or incompletely represent the objective, which happens because the formulation does not capture the true nature of the optimization goal. More generally, this reflects that the objective function must align with the problem's stated goals and constraints.",
    "example": "# Wrong: Maximize: z = r_b * x_b + r_h * x_h + r_s * x_s\n# Correct: Maximize: z = (1-p_b) * r_b * x_b + (1-p_h) * r_h * x_h + (1-p_s) * r_s * x_s",
    "iteration": 0,
    "version": 1,
    "task_id": "A186",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 56,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision quantities in the problem represent indivisible counts or choices versus divisible amounts such as flows. For example, when the problem statement mentioned the number of pills to take per day, which should be integers, the failed mathematical model did not specify integer constraints.\nThis insight applies when the decision variables represent items that are either countable, discrete choices, or when the model specifically states integer constraints are required.\nThis insight does NOT apply when decision quantities in the problem represent divisible amounts rather than indivisible counts or choices. For example, when the problem statement mentions the number of glasses of milk or plates of vegetables, which can be consumed in fractional amounts, indicating that continuous variables are appropriate.",
    "explanation": "When the problem involves decision variables that represent quantities of indivisible items, such as pills, the best practice is to define these variables as integer or binary. A common mistake is to define them as continuous, which happens because the modeler overlooks the discrete nature of the decision. More generally, this reflects that decision variables should align with the physical or logical nature of the problem they represent.",
    "example": "# Wrong: Define x_z and x_s as continuous variables\nx_z \\geq 0\nx_s \\geq 0\n\n# Correct: Define x_z and x_s as integer variables\nx_z \\in \\mathbb{Z}, x_z \\geq 0\nx_s \\in \\mathbb{Z}, x_s \\geq 0",
    "iteration": 0,
    "version": 1,
    "task_id": "A014",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "A235",
        "E034",
        "F140",
        "E009"
      ],
      "negative": [
        "A176"
      ],
      "unretrieved": [],
      "irrelevant": [
        "B081"
      ],
      "invalid": [
        "E003",
        "E014",
        "E020",
        "E013",
        "F088"
      ]
    }
  },
  {
    "insight_id": 57,
    "taxonomy": {
      "General Formulation": {
        "Objective Specification": [
          "Redundant Auxiliary Variables"
        ]
      }
    },
    "condition": "This insight applies when auxiliary variables merely re-express existing linear combinations without adding modeling value. For example, when the optimization problem's objective function is directly the cost of pills without needing any additional variables to express it.",
    "explanation": "When the problem involves an objective function that can be directly expressed using existing decision variables, the best practice is to avoid introducing redundant auxiliary variables. A common mistake is to include such variables, which happens because modelers may think they need to explicitly re-express the objective in terms of separate components. More generally, this reflects that objective functions should be formulated as directly as possible, avoiding unnecessary complexity.",
    "example": "# Wrong: Introducing redundant cost variables\nMinimize cost_zodiac * x_z + cost_sunny * x_s\n\n# Correct: Directly specify the cost in the objective\nMinimize x_z + 3 * x_s",
    "iteration": 0,
    "version": 1,
    "task_id": "A014",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 58,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision variables can represent continuous quantities, but the model incorrectly defines them as discrete or integer. For example, when the problem statement mentioned maximizing profit by allocating land to different crops, the decision variables should be continuous to allow for fractional acre allocations, but the failed model defined them as integers. This insight applies when the problem involves maximizing profit by allocating resources like land or other divisible resources OR when there is no requirement for allocations to be in whole units. This insight does NOT apply when decision variables inherently represent discrete units that cannot be divided. For example, when the problem statement mentions selecting whole food items to meet nutritional needs, indicating that fractions of a food item cannot be purchased or consumed.",
    "explanation": "When the problem involves optimizing continuous quantities, such as land allocation, the best practice is to define decision variables as continuous rather than discrete or integer. A common mistake is defining them as integers, which happens because of a misinterpretation of the problem's requirement for divisible resource allocation. More generally, this reflects that decision variables representing divisible resources should be modeled as continuous to capture any fractional allocations effectively.",
    "example": "# Wrong\nx_B \\in \\mathbb{Z}_+ \n\n# Correct\nx_B \\in \\mathbb{R}_+",
    "iteration": 0,
    "version": 1,
    "task_id": "A031",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "F163",
        "F167"
      ],
      "negative": [
        "E012"
      ],
      "unretrieved": [
        "A026"
      ],
      "irrelevant": [
        "F167",
        "E021"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 59,
    "taxonomy": {
      "General Formulation": {
        "Explicit Bounds": []
      }
    },
    "condition": "This insight applies when the problem description provides natural limits on decision variables, but the model does not incorporate these limits. For example, when the problem statement mentioned 300 total acres available, this natural limit should be explicitly set as an upper bound on the decision variables representing acres of blueberries and raspberries.",
    "explanation": "When the problem involves decision variables with known physical, economic, or logical limits, the best practice is to set explicit bounds to enhance model performance and prevent infeasibility. A common mistake is omitting these bounds, which happens because of oversight or lack of attention to physical constraints. More generally, this reflects that incorporating explicit bounds helps solvers optimize more effectively by reducing the search space.",
    "example": "# Wrong\nmodel.addVar(name='Blueberries', lb=0)\n\n# Correct\nmodel.addVar(name='Blueberries', lb=0, ub=300)",
    "iteration": 0,
    "version": 1,
    "task_id": "A031",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 60,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Incorrect Relational Operators"
        ]
      }
    },
    "condition": "This insight applies when natural-language statements such as 'at most' or 'at least' must be translated into algebraic inequalities. This insight applies when the constraints primarily involve translating percentage or proportion statements from natural language to algebraic inequalities. This insight does NOT apply when the constraints involve relational comparisons, combined constraints, or other forms of constraints not directly related to translating percentage or proportion statements.",
    "explanation": "When the problem involves translating constraints from natural language to algebraic forms, the best practice is to use correct relational operators to match the problem's intent. A common mistake is using incorrect operators, such as misunderstanding the proportion constraint, which happens because the relational meaning of language statements can be misinterpreted. More generally, this reflects that translating problem constraints accurately is crucial for correct optimization modeling.",
    "example": "# Wrong: x_o <= 0.3(x_o + x_d)\n# Correct: x_o <= 0.3 * (x_o + x_d)",
    "iteration": 0,
    "version": 1,
    "task_id": "F039",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "F103",
        "A093"
      ],
      "negative": [
        "F203",
        "F102",
        "A083",
        "A026",
        "F140",
        "F103"
      ],
      "unretrieved": [],
      "irrelevant": [
        "A171",
        "B029",
        "A235",
        "B096",
        "E025",
        "F169",
        "F163",
        "F152",
        "F083",
        "B062",
        "F057",
        "F122",
        "A240",
        "A176",
        "A092",
        "A104",
        "F019",
        "F167",
        "F021",
        "B016",
        "F080",
        "A236",
        "A084",
        "B064",
        "B039",
        "B023",
        "E023",
        "E029",
        "E021",
        "E003",
        "E017",
        "E001",
        "E014",
        "E012",
        "E005",
        "E028",
        "E020",
        "E013",
        "E034",
        "A033",
        "A179",
        "A172",
        "F203",
        "A112",
        "F088",
        "B081",
        "E002",
        "E006",
        "E011",
        "E009",
        "B019"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 61,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision quantities in the problem represent indivisible counts or choices versus divisible amounts such as flows. For example, when the problem statement requires the number of otters and dolphins, which are discrete quantities.",
    "explanation": "When the problem involves choosing variables to represent indivisible counts, the best practice is to define integer variables. A common mistake is to use continuous variables, which happens because of oversight or misunderstanding of the nature of the problem. More generally, this reflects that matching the variable type to the problem's decision nature is essential for correct modeling.",
    "example": "# Wrong: o = model.addVar(name='otters')\n# Correct: o = model.addVar(vtype=GRB.INTEGER, name='otters')",
    "iteration": 0,
    "version": 1,
    "task_id": "F039",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "F102",
        "B019"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [
        "F057",
        "B068"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 62,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision variables have natural limits or represent specific types of quantities. For example, when the problem statement limits the available hours per furnace to 12 hours, or mentions that the number of times each method is used per furnace is an integer count.",
    "explanation": "When the problem involves decision variables with clear physical, logical limits or type distinctions, the best practice is to explicitly define bounds for variables and use integer variables for discrete counts and continuous variables for divisible amounts. A common mistake is neglecting these bounds or using incorrect variable types, which happens because the modeler may assume the solver will manage feasibility or overlook the nature of the decision. More generally, this reflects that explicit bounds and correct variable type selection are crucial for accurately capturing the problem's constraints.",
    "example": "# Wrong: Continuous variable definition\nx = model.addVars(num_furnaces, num_methods, name='x', lb=0.0, vtype=GRB.CONTINUOUS)\n\n# Correct: Integer variable definition\nx = model.addVars(num_furnaces, num_methods, name='x', lb=0, vtype=GRB.INTEGER)\n\n# Wrong\nx_1, x_2 \\geq 0\n\n# Correct\n0 \\leq x_1, x_2 \\leq 6",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "B041"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 63,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Incorrect Relational Operators"
        ]
      }
    },
    "condition": "This insight applies when natural-language statements such as 'at most' or 'at least' must be translated into algebraic inequalities. For example, when the problem statement mentioned that at least 30 tons of steel must be produced and at most 12 hours are available per furnace.",
    "explanation": "When the problem involves translating constraints from natural language, the best practice is to use appropriate relational operators ('\u2264', '\u2265') to match the intent of 'at most' or 'at least' conditions. A common mistake is using incorrect operators, which happens because the modeler does not align the mathematical formulation with the problem's language. More generally, this reflects that correct interpretation of problem statements is crucial for proper constraint formulation.",
    "example": "# Wrong\nx_1 + x_2 > 3\n\n# Correct\nx_1 + x_2 \u2265 3\n\n# Wrong: Production constraint with incorrect operator\nk * (x1 + x2) * F = d\n\n# Correct: Production constraint with correct operator\nk * (x1 + x2) * F >= d",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "B041"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [
        "A240",
        "B080",
        "A229",
        "F021"
      ],
      "negative": [
        "A186"
      ],
      "unretrieved": [],
      "irrelevant": [
        "A180",
        "F122",
        "B015",
        "E017",
        "E019",
        "E001",
        "E004",
        "E007",
        "E024",
        "E002",
        "E006",
        "F080"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 64,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Resource Pooling"
        ]
      }
    },
    "condition": "This insight applies when the problem domain contains multiple identical resources that are substitutable and individual identities do not matter. For example, when the problem statement involves allocating two furnaces to steelmaking methods without distinguishing between the furnaces themselves.",
    "explanation": "When the problem involves identical resources that can be pooled, the best practice is to model them collectively, focusing on the total allocation. A common mistake is to separate allocations unnecessarily, which happens because the modeler fails to recognize the interchangeability of resources. More generally, this reflects that identifying when resources can be pooled simplifies the model and reduces complexity.",
    "example": "# Wrong: Separate constraints for each furnace\nmodel.addConstr(time_m1 * x[0, 0] + time_m2 * x[0, 1] <= max_furnace_hours)\nmodel.addConstr(time_m1 * x[1, 0] + time_m2 * x[1, 1] <= max_furnace_hours)\n\n# Correct: Pooled constraint\nmodel.addConstr(time_m1 * (x[0, 0] + x[1, 0]) + time_m2 * (x[0, 1] + x[1, 1]) <= num_furnaces * max_furnace_hours)",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "B041"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 65,
    "taxonomy": {
      "General Formulation": {
        "Objective Specification": [
          "Redundant Auxiliary Variables"
        ]
      }
    },
    "condition": "This insight applies when the problem involves minimizing an absolute difference in values between two parts. For example, when the problem statement mentioned minimizing the difference in value between the two sons' inheritance shares.",
    "explanation": "When the problem involves minimizing an absolute difference between two quantities, the best practice is to use auxiliary variables only if they simplify or improve the model's tractability. A common mistake is introducing unnecessary auxiliary variables when the expression can be linearized directly in the constraints, which happens because of a misunderstanding of the linearization process for absolute values. More generally, this reflects that redundant auxiliary variables should be avoided when direct expression is feasible.",
    "example": "# Wrong: Introducing an auxiliary variable for absolute difference\nm.addConstr(2 * sum_values_y - V_total <= d, \"abs_diff_upper\")\nm.addConstr(-(2 * sum_values_y - V_total) <= d, \"abs_diff_lower\")\n\n# Correct: Directly linearize the absolute difference in the constraints\nm.addConstr(sum_values_y - (V_total - sum_values_y) <= d)\nm.addConstr(-(sum_values_y - (V_total - sum_values_y)) <= d)",
    "iteration": 0,
    "version": 1,
    "task_id": "B032",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 66,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Set-Partitioning/Assignment"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires each item to be exclusively assigned to exactly one choice among many. For example, when the problem statement mentioned that each item of the inheritance must be given to either of the two sons. This insight applies when the problem requires exclusive assignments, such as ensuring each resource is used uniquely, or when entities must be assigned to exactly one option among several. This insight does NOT apply when items can be assigned to multiple groups simultaneously, or when shared assignments are possible.",
    "explanation": "When the problem involves assigning items to different groups, the best practice is to ensure that each item is assigned to exactly one group. A common mistake is failing to enforce this exclusivity, which happens because of neglecting to model the assignment constraints accurately. More generally, this reflects that set-partitioning constraints are essential to ensure proper assignment of items in allocation problems.",
    "example": "# Wrong: Incorrect model without explicit assignment constraint\n# No constraint ensuring each item is assigned to exactly one son\n\n# Correct: Explicitly ensure each item is assigned to exactly one son\nfor i in range(1, 12):\n    m.addConstr(y_vars[i] + (1 - y_vars[i]) == 1)",
    "iteration": 0,
    "version": 1,
    "task_id": "B032",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B032",
        "B062"
      ],
      "negative": [],
      "unretrieved": [
        "B068",
        "B081",
        "B037"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 67,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Set-Partitioning/Assignment"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires each item or task to be exclusively assigned to exactly one choice among many. For example, when each car must be parked on either the left or right side of the street.",
    "explanation": "When the problem involves assigning items to exclusive choices, the best practice is to use binary variables with assignment constraints to ensure each item is allocated to one and only one choice. A common mistake is to overlook these constraints, which happens because the exclusivity requirement is not explicitly enforced. More generally, this reflects that assignment problems require explicit constraints ensuring singular assignments per item.",
    "example": "# Wrong: No explicit constraint for each car's side assignment\n# Correct: \u2211_{s=1}^{2} x[i, s] == 1 for each i",
    "iteration": 0,
    "version": 1,
    "task_id": "B080",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B080"
      ],
      "negative": [],
      "unretrieved": [
        "B032"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 68,
    "taxonomy": {
      "General Formulation": {
        "Objective Specification": [
          "Sum vs. Makespan Confusion"
        ]
      }
    },
    "condition": "This insight applies when the objective involves minimizing the maximum usage or load distribution across multiple entities. For example, when minimizing the maximum length of street used or balancing the parking distribution to minimize the maximum length occupied on either side.\nThis insight applies when the objective involves minimizing the maximum usage or load distribution across sequential operations to optimize the overall process efficiency. For example, when scheduling operations in a sequence of stages, such as vats in a dyeing plant, or scheduling products across machines to minimize the completion time of the last task, indicating a need to balance the workload across the sequence to minimize the maximum time spent in any stage or machine.\nThis insight does NOT apply when the objective is to minimize the total sum of resources or time used, rather than the maximum usage across entities or operations. For example, when the problem statement emphasizes reducing total costs or total production time without regard to distribution or load balancing.",
    "explanation": "When the problem involves minimizing the maximum usage or load, the best practice is to define an auxiliary variable representing the maximum and minimize this variable. A common mistake is to confuse this with minimizing the total sum, which happens because the objective's scope is misunderstood. More generally, this reflects that clarity in distinguishing between sum and maximum objectives is crucial to correctly capturing the problem's intent.",
    "example": "# Wrong: Minimize sum of lengths\nMinimize \u2211_{i=1}^n \u03bb_i * (1 + x_i)\n\n# Correct: Minimize maximum length\nmodel.addVar(name='L_max', lb=0.0, vtype=GRB.CONTINUOUS)\nmodel.setObjective(L_max, GRB.MINIMIZE)\nfor s in sides:\n    model.addConstr(L_max >= quicksum(car_lengths[i] * x[i, s] for i in cars))",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "B080"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B034"
      ],
      "negative": [],
      "unretrieved": [
        "B034",
        "A104",
        "B080",
        "B037"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 69,
    "taxonomy": {
      "Domain Modeling": {
        "Production Planning": []
      }
    },
    "condition": null,
    "explanation": "When the problem involves production planning with conditional production constraints, the best practice is to correctly model the conditional dependencies between products using implications or constraints that reflect the problem requirements. In this problem, if Bright Future Toys manufactures model cars, they must also produce building blocks. The failed model does not correctly enforce this requirement, which can lead to suboptimal or infeasible solutions. The gold-standard program uses an indicator constraint to link the binary variable indicating the production of model cars to the production quantity of building blocks, ensuring the conditional production constraint is respected. In general, when the production of one item is contingent on another, the model should include constraints that correctly represent such dependencies.",
    "example": "# Wrong:\nC6: Y_C <= Y_B  # (model cars imply building blocks)\n\n# Correct:\nmodel.addConstr((use_toy[\"cars\"] == 1) >> (qty[\"blocks\"] >= 1), \"Cars_Implies_Blocks_Indicator\")",
    "iteration": 0,
    "version": 1,
    "task_id": "B019",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 70,
    "taxonomy": {
      "General Formulation": {
        "Big-M & Indicator Variables": [],
        "Incorrect Relational Operators": []
      }
    },
    "condition": "Applies when constraints depend on logical on/off conditions controlled by binary variables or when formulating constraints that represent logical relationships between entities. In the given problem, if Bright Future Toys manufactures robots, they will not manufacture dolls, which is a logical condition that can be controlled using binary variables or indicator constraints.",
    "explanation": "In problems that involve conditional constraints reliant on binary decisions, the best practice is to use indicator constraints to directly represent conditional logic, as they inherently handle the logical on/off nature without requiring large constants. A common mistake is using a big-M formulation with a large constant, which can lead to numerical instability and suboptimal solutions. In the given problem, the failed model used a big-M approach to link production quantities with binary variables, whereas the gold-standard program used indicator constraints to more accurately model the conditional constraints without the risk of numerical instability.",
    "example": "# Wrong:\nC3: R <= M \\cdot (1 - Y_D) \n\n# Correct:\nmodel.addConstr((use_toy[\"robots\"] == 1) >> (qty[\"dolls\"] == 0), \"Robots_No_Dolls_Indicator\")",
    "iteration": 0,
    "version": 1,
    "task_id": "B019",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 71,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Incorrect Relational Operators"
        ]
      }
    },
    "condition": "This insight applies when natural-language statements such as 'at least' must be translated into algebraic inequalities. For example, when the problem statement mentioned that at least 40% of the items made must be brownies. This insight applies when constraints involve translating natural language percentages or proportions into mathematical inequalities. This insight does NOT apply when the problem statement involves fixed quantities or uses relational operators that do not involve percentages or proportions.",
    "explanation": "When the problem involves constraints that describe proportions or percentages, the best practice is to accurately translate these statements into mathematical inequalities. A common mistake is using an incorrect relational operator, which happens because the translation does not match the intended meaning of the constraint. More generally, this reflects that careful interpretation of natural language constraints is crucial to ensure the model accurately represents the problem requirements.",
    "example": "# Wrong\n5x >= 2y\n# Correct\n3x >= 2y",
    "iteration": 0,
    "version": 1,
    "task_id": "A051",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [
        "A229"
      ],
      "unretrieved": [],
      "irrelevant": [
        "F122",
        "E004",
        "E002",
        "E006",
        "F080"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 72,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem statement involves resource constraints for chocolate mix and lemon mix, ensuring that the resources used do not exceed available amounts.",
    "explanation": "When the problem involves constraints on resource usage, the best practice is to ensure that each resource constraint accurately reflects the available resource capacity. A common mistake is omitting constraints or misrepresenting them, which happens because resource availability is not properly enforced in the model. More generally, this reflects that maintaining accurate resource balance is fundamental to correctly modeling resource allocation problems.",
    "example": "# Wrong\nNo constraint for chocolate mix\n# Correct\n5x <= 2500",
    "iteration": 0,
    "version": 1,
    "task_id": "A051",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "F203",
        "B019",
        "B066",
        "A104",
        "F019",
        "A236",
        "A084"
      ],
      "negative": [
        "B096",
        "B039",
        "F091",
        "B064"
      ],
      "unretrieved": [],
      "irrelevant": [
        "F169",
        "F091",
        "F192",
        "A223",
        "A236",
        "A084",
        "B031",
        "B064",
        "A033",
        "F140",
        "F126",
        "B016",
        "B019",
        "B066"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 73,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Redundant Auxiliary Variables"
        ]
      }
    },
    "condition": "This insight applies when auxiliary variables merely re-express existing linear combinations without adding modeling value. For example, when the problem statement involves maximizing ending inventory, and the failed model directly incorporates inventory balance into the objective without defining separate ending inventory variables.",
    "explanation": "When the problem involves optimizing based on derived quantities, it's more efficient to define auxiliary variables that capture these quantities explicitly. The best practice is to create variables for ending inventory and maximize them directly. A common mistake is embedding complex expressions directly into the objective, which happens because auxiliary variables are overlooked in favor of immediate expressions. More generally, this reflects that auxiliary variables can simplify and clarify the formulation by capturing derived quantities explicitly.",
    "example": "# Wrong:\n\\text{Maximize } (I_L + x_L - D_L) + (I_S + x_S - D_S)\n\n# Correct:\nInvEnd = model.addVars(products, name=\"InvEnd\", vtype=GRB.INTEGER, lb=0)\nmodel.setObjective(gp.quicksum(InvEnd[p] for p in products), GRB.MAXIMIZE)",
    "iteration": 0,
    "version": 1,
    "task_id": "B087",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 74,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Multi-Commodity Flow"
        ]
      }
    },
    "condition": "This insight applies when the problem domain contains distinct commodities that share capacities. For example, when the problem described two distinct products (anti-itch injections and topical cream) produced using shared resources (factories and plastic), and the failed model did not allocate plastic in a way that considers the combined requirements of both products effectively.",
    "explanation": "When the problem involves multiple products sharing the same resources, the best practice is to model each product's resource requirements separately but consider their combined impact on shared constraints like capacity. A common mistake is to overlook the interaction between these commodities, which happens because of a failure to incorporate a holistic view of resource utilization across all products. More generally, this reflects that in resource allocation problems, shared resource constraints require a careful balance of all competing demands.",
    "example": "# Wrong\np_N \\cdot x_N + p_W \\cdot x_W \\leq P\n\n# Correct\nmodel.addConstr(\n    plastic_north * x_N + plastic_west * x_W <= plastic_limit,\n    name=\"PlasticLimit\"\n)",
    "iteration": 0,
    "version": 1,
    "task_id": "A236",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "B016"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 75,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem statement mentioned the need to balance the allocation of resources across different machines in a production setting.",
    "explanation": "When the problem involves allocating resources across different machines with specific capacities, the best practice is to ensure that resource usage balances with available capacity at each machine. A common mistake is to overlook the need for detailed flow conservation or allocation balance at every stage, which happens because constraints do not account for resources being processed on specific machines. More generally, this reflects that modeling resource allocation requires careful consideration of the balance between inflow and outflow at each resource node.",
    "example": "# Wrong\nC1: t_{A1,I} \\cdot x_I + t_{A1,II} \\cdot x_{II} \\leq H_{A1}\n\n# Correct\nmodel.addConstr(proc_times[('I', 'A1')] * x_IA1 + proc_times[('II', 'A1')] * x_IIA1 <= capacities['A1'], \"Cap_A1\")",
    "iteration": 0,
    "version": 1,
    "task_id": "B030",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B030"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [
        "F083",
        "A104",
        "F019",
        "B087",
        "A179",
        "A172",
        "B031",
        "B030"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 76,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Indexing & Data Structure Alignment"
        ]
      }
    },
    "condition": "This insight applies when variables are indexed over sets or dictionaries that must align with the keys of the provided data. For example, when the problem statement involves indexing products and machines in a way that must correspond to specific processing times and capacities.",
    "explanation": "When the problem involves defining variables for specific products and machines, the best practice is to align variable indices with the corresponding keys in parameter dictionaries. A common mistake is to mismatch indices or miss necessary indices, which happens because the variable definitions do not correspond to the data structure used for parameters. More generally, this reflects that careful alignment between variable indices and parameter indices is crucial to avoid errors and ensure model correctness.",
    "example": "# Wrong\nx_{I}, x_{II}, x_{III} \n\n# Correct\nX = model.addVars(products, name=\"X\", lb=0.0, vtype=GRB.INTEGER)",
    "iteration": 0,
    "version": 1,
    "task_id": "B030",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 77,
    "taxonomy": {
      "Domain Modeling": {
        "Production Planning": [
          "Inventory Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves materials or products that carry over between periods and must satisfy stock-flow balance. For example, when the problem statement involved planning production quantities that need to match machine processing capabilities. This insight applies when managing production across multiple machines and periods, requiring a balance between production capabilities and demand, considering capacity and storage constraints. For example, when the problem statement mentions machine processing times, production targets, and capacity constraints over time. This insight does NOT apply when the primary focus is on balancing inventory levels rather than production flow through machines. For example, when the problem statement mentions managing inventory and warehouse capacities without specific machine-level production scheduling.",
    "explanation": "When the problem involves planning production quantities over different machines, the best practice is to ensure that production flow is balanced based on machine processing capabilities. A common mistake is to ignore the need for flow balance at each process stage, which happens because the constraints do not ensure that production at each machine matches the machine's capacity. More generally, this reflects that ensuring a balance between production input and output is essential for accurate production planning.",
    "example": "# Wrong\nC2: t_{A2,I} \\cdot x_I + t_{A2,II} \\cdot x_{II} + t_{A2,III} \\cdot x_{III} \\leq H_{A2}\n\n# Correct\nmodel.addConstr(\n    proc_times[('I', 'A2')] * x_IA2 +\n    proc_times[('II', 'A2')] * x_IIA2 +\n    proc_times[('III', 'A2')] * x_IIIA2 <= capacities['A2'], \"Cap_A2\")",
    "iteration": 0,
    "version": 1,
    "task_id": "B030",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B015",
        "B030",
        "B049"
      ],
      "negative": [
        "B066"
      ],
      "unretrieved": [
        "B087",
        "B066",
        "B015",
        "B000"
      ],
      "irrelevant": [],
      "invalid": [
        "B049"
      ]
    }
  },
  {
    "insight_id": 78,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Variable Bound Specification Errors"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains variables whose bounds need to be defined using data structures that map directly to the index set. For example, when the formulation included production variables with capacities specified per time period.",
    "explanation": "When the problem involves defining variable bounds per index, the best practice is to use a dictionary that maps indices to bounds. A common mistake is using an aggregate expression, which happens because the solver expects individual bounds per index. More generally, this reflects that variable bounds must correspond directly to their respective indices.",
    "example": "# Wrong: x = model.addVars(weeks, lb=0, ub=gp.quicksum(capacity[t] for t in weeks), vtype=GRB.CONTINUOUS, name='Production')\n# Correct: x = model.addVars(weeks, lb=0, ub=capacity, vtype=GRB.CONTINUOUS, name='Production')",
    "iteration": 0,
    "version": 1,
    "task_id": "B094",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 80,
    "taxonomy": {
      "General Formulation": {
        "Objective Specification": [
          "Sum vs. Makespan Confusion"
        ]
      }
    },
    "condition": "This insight applies when the problem involves maximizing the number of complete products. For example, when the problem statement mentioned maximizing the output of complete products by balancing the production of components.",
    "explanation": "When the problem involves maximizing the number of complete products, the best practice is to directly focus the objective on the comprehensive measure related to the overall product count, using appropriate decision variables to accurately model the discrete nature of the output. A common mistake is framing the objective around indirect or redundant expressions or using only continuous variables for all quantities, which happens either because the model shifts focus to subproblems or uses indirect means, or because the modeler may overlook the need to capture the indivisibility of the final product. More generally, this reflects that one must distinguish between optimizing a comprehensive objective like total output and ensuring decision variables align with the physical reality of the quantities they represent.",
    "example": "# Wrong: \n\\( \\max \\left( \\min_{c \\in C} \\left( \\sum_{w \\in W} R_{wc} \\cdot x_{wc} \\right) \\right) \\) \n\n# Only continuous variables are defined.\n\n# Correct: \nmodel.setObjective(z, GRB.MAXIMIZE)  # where z is the number of complete products\nz = model.addVar(name=\"z\", vtype=GRB.INTEGER)  # Number of complete products",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "B031"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "B031"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 81,
    "taxonomy": {
      "Code Implementation": {
        "Data I/O & Validation": [
          "Missing Data Defaults"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains optional parameters that are not defined and need default values for model consistency. For example, when the formulation included constraints with variables like D_E, D_G, D_D, and D_F, which were not defined.",
    "explanation": "When the problem involves optional parameters that are not always present. The best practice is to provide default values to maintain consistency across the model. A common mistake is to reference these undefined parameters directly, which happens because the modeler assumes their presence without validation. More generally, this reflects that missing data should be handled gracefully by assigning defaults to avoid errors.",
    "example": "# Wrong: model.addConstr(S_F >= S_E + D_E, \"C3\")\n# Correct: model.addConstr(S_F >= S_E, \"C3\")",
    "iteration": 0,
    "version": 1,
    "task_id": "B073",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 82,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Strict Inequalities"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains strict inequality relations that are not directly compatible with the solver's capabilities. For example, when attempting to ensure that one start time is strictly greater than another, but without negative infinity or undefined constants.",
    "explanation": "When the problem involves inequality constraints that are inherently strict. The best practice is to approximate strict inequalities using non-strict equivalents with adjustments. A common mistake is to directly implement strict inequalities, which happens because modelers misinterpret solver capabilities. More generally, this reflects that solver limitations require adapting mathematical constraints into compatible forms.",
    "example": "# Wrong: model.addConstr(S_D > S_A + D_A, \"C2\")\n# Correct: model.addConstr(S_D >= S_A + D_A, \"C2\")",
    "iteration": 0,
    "version": 1,
    "task_id": "B073",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 83,
    "taxonomy": {
      "General Formulation": {
        "Objective Specification": [
          "Sum vs. Makespan Confusion"
        ]
      }
    },
    "condition": "This insight applies when multiple resources or activities can run in parallel and the objective is ambiguous between total completion time and makespan. For example, when the problem statement involves minimizing the total cost, which includes both work costs dependent on project duration and machine rental costs related to a specific activity period.",
    "explanation": "When the problem involves optimizing costs related to both the duration of a project and specific rental periods, the best practice is to clearly distinguish between minimizing total project duration (makespan) and specific activity-related durations. A common mistake is to conflate these objectives or introduce redundant auxiliary variables, which happens because of a lack of clarity in how different cost components relate to time. More generally, this reflects that objectives should be carefully defined to capture the specific time-related costs involved.",
    "example": "# Wrong: Introduces redundant variable C_{project}\nC_{project} \u2265 S_A + D_A\nMinimize x_{truck} + x_{van} + x_{motorcycle} + x_{electric}\n# Correct: Directly use expressions without auxiliary variable\nobjective = cost_work_per_day * Makespan + cost_machine_per_day * MachineRentalDuration\nMinimize 100 * T + 50 * V * y_V + 10 * M",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "B073",
      "B023"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 84,
    "taxonomy": {
      "Domain Modeling": {
        "Scheduling": [
          "Precedence Constraints"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves tasks or activities that must follow a specific order. For example, when the problem statement mentioned precedence relationships such as A -> G, D, which means activity G and D cannot start until A is complete. This insight applies when the problem description involves sequential processing of tasks or activities across multiple stages or resources. For example, when the problem statement specifies that products must be processed sequentially on different machines, maintaining the same order for each product. This insight does NOT apply when tasks are independent or when order does not impact the outcome, such as parallel processing scenarios where all tasks can occur simultaneously without any dependencies.",
    "explanation": "When the problem involves task precedence, the best practice is to ensure all precedence relationships are represented accurately to reflect the entire project flow. A common mistake is to overlook certain precedence relationships, use incorrect relational operators, or fail to integrate them properly into the model, which happens because modelers may focus on isolated task dependencies without considering their impact on the overall schedule. More generally, this reflects that precedence constraints must be comprehensive and clearly capture technological or logical order requirements.",
    "example": "# Wrong: Missed comprehensive integration of precedence constraints\nC_A \u2264 S_G (Activity G starts after A)\n# Correct: Ensure all precedence relationships are accurately captured\nS_G \u2265 C_A (Activity G starts after A completes)\nmodel.addConstr(S['C'] >= S['F'] + durations['F'], name=\"Prec_F_C\")",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "B073"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B034"
      ],
      "negative": [],
      "unretrieved": [
        "B037"
      ],
      "irrelevant": [
        "A112"
      ],
      "invalid": [
        "B034"
      ]
    }
  },
  {
    "insight_id": 85,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Set-Partitioning/Assignment"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires each item or task to be exclusively assigned to exactly one choice among many. For example, when the problem statement mentioned the company wants to choose only one of the two transportation options: van or electric vehicle. This insight applies when a problem involves distributing a set of indivisible items between parties such that each item is assigned to exactly one party, minimizing the imbalance in some metric. For example, when the problem statement involves dividing a set of valuable items between two heirs to minimize the difference in total value between their shares. This insight does NOT apply when the problem requires shared or overlapping assignments, such as when multiple parties can share resources or when assignments are not exclusive.",
    "explanation": "When the problem involves exclusive assignment choices, the best practice is to use set-partitioning constraints and binary variables to enforce that each item is assigned to exactly one option. A common mistake is incorrectly or incompletely modeling this exclusivity or using overly large M values without constraints to tighten them, which happens because the constraints fail to capture the mutual exclusivity condition. More generally, this reflects that exclusive choices should be modeled with set-partitioning constraints to ensure no overlap in assignments.",
    "example": "# Wrong: x_van + x_electric <= M * y_van_or_electric\nx_{van} \\leq M \\cdot y_{van/electric}\n# Correct: y_V + y_E <= 1\nx_{van} <= 10 * y_V\nx_{electric} <= 10 * y_E",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "B023"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B062",
        "B023",
        "B032"
      ],
      "negative": [],
      "unretrieved": [
        "B032"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 86,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Incorrect Relational Operators"
        ]
      }
    },
    "condition": "This insight applies when natural-language statements such as 'at most' or 'at least' must be translated into algebraic inequalities. For example, when the problem statement specifies precedence constraints such as E -> F, which should be modeled as a 'greater than or equal to' constraint.",
    "explanation": "When the problem involves setting limits or thresholds, the best practice is to use the appropriate relational operators (\u2264, \u2265) that match the intent of the constraint (like 'at most' or 'at least'). A common mistake is using incorrect relational operators, which happens because of a misunderstanding of the problem's requirements. More generally, this reflects that correctly interpreting and translating problem statements into algebraic constraints is crucial for accurate modeling.",
    "example": "# Wrong: P_truck * x_truck + P_van * x_van + P_motorcycle * x_motorcycle + P_electric * x_electric = L\nC_E < S_F (Activity F starts after E)\n# Correct: P_truck * x_truck + P_van * x_van + P_motorcycle * x_motorcycle + P_electric * x_electric <= L\nS_F \u2265 C_E (Activity F starts after E completes)",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "B073",
      "B023"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B080"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 88,
    "taxonomy": {
      "General Formulation": {
        "Big-M & Indicator Variables": []
      }
    },
    "condition": "This insight applies when constraints depend on logical on/off conditions controlled by binary variables. For example, in this problem, the failed mathematical model attempted to apply conditional constraints without using binary variables and indicator constraints, which are necessary to enforce logical dependencies in a linear programming context.",
    "explanation": "When the problem involves logical conditions, the best practice is to use binary variables in conjunction with indicator constraints to appropriately enforce those conditions. A common mistake is to directly translate conditions into implications without using binary variables, which happens because the solver cannot inherently understand logical conditions without explicit formulation. More generally, this reflects that Big-M and indicator variables are essential for modeling logical dependencies in linear optimization problems.",
    "example": "# Wrong: \nC3: x_A \u2265 1 \u21d2 x_B \u2265 2\nC4: x_B \u2265 1 \u21d2 x_C \u2265 1\n\n# Correct:\nmodel.addConstr((use_A == 1) >> (orders_B >= 2), \"Conditional_A_implies_B_orders\")\nmodel.addConstr((use_B == 1) >> (orders_C >= 1), \"Conditional_B_implies_C_orders\")",
    "iteration": 0,
    "version": 1,
    "task_id": "B020",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 89,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Source Flow Constraint"
        ]
      }
    },
    "condition": "This insight applies when the problem involves maximizing flow from a source node to a sink node in a network with capacity constraints and intermediate nodes with flow conservation. For example, when the problem statement mentioned transferring resources from the Central Supply Hub (Sector 0) to the Farthest Outpost (Sector 8) on Mars.",
    "explanation": "When the problem involves maximizing flow in a network, the best practice is to ensure that the total outflow from the source equals the total inflow to the sink, enforcing a source-to-sink flow balance. A common mistake is omitting this constraint, which happens because the model may allow inflows to exceed outflows at the sink without ensuring all flow originates from the source. More generally, this reflects that maximizing flow requires explicit source-to-sink balance constraints.",
    "example": "# Wrong\nf_ij <= c_ij for all i, j; sum(f_ji) = sum(f_ij) for all i != 0, 8\n\n# Correct\nf_ij <= c_ij for all i, j; sum(f_ji) = sum(f_ij) for all i != 0, 8; sum(f_0j) - sum(f_i0) = sum(f_i8) for all i",
    "iteration": 0,
    "version": 1,
    "task_id": "E061",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 91,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem statement mentioned conserving flow at each data center except the source and destination. This insight applies when keywords like 'nodal balance', 'intermediate nodes', and 'resource redistribution' appear in the problem description. For example, when the problem involves relocating resources among regions to meet demand and supply constraints. This insight does NOT apply when the problem involves maximizing flow, solving a transportation or assignment problem without intermediate nodes, or finding paths that maximize the minimum capacity along the path. For example, when the problem statement involves calculating the maximum flow from a source to a destination node or direct allocations between supply and demand regions.",
    "explanation": "When the problem involves flow conservation on a network, the best practice is to ensure that for all intermediate nodes, the inflow equals the outflow. A common mistake is incorrect formulation of flow conservation constraints that do not properly balance inflow and outflow, which happens because of misalignment in summing flows entering and leaving nodes. More generally, this reflects that flow conservation constraints must be correctly applied to ensure network feasibility.",
    "example": "# Wrong: Incorrect balance at intermediate nodes\n\\sum_{j=0}^{7} f_{ji} = \\sum_{j=0}^{7} f_{ij}\n\n# Correct: Proper balance at intermediate nodes\n\\sum_{j=0}^{7} f_{ji} = \\sum_{j=0}^{7} f_{ij} \\text{ for } i \\neq 0, 7",
    "iteration": 0,
    "version": 1,
    "task_id": "E064",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "E071",
        "E061",
        "E067",
        "E066",
        "E069"
      ],
      "negative": [
        "E069",
        "E059",
        "E052",
        "E107",
        "E103",
        "B099"
      ],
      "unretrieved": [
        "E107",
        "E038",
        "E035"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 93,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem required ensuring the flow entering and leaving any intermediate data center is equal. This insight applies when the problem description involves a directed network with specific source and sink nodes, and nodal balance must be maintained only at intermediate nodes. For example, when the problem statement mentions ensuring flow conservation at all nodes except the central supply hub and the farthest outpost, or when maximizing flow through a network with distinct source and sink nodes. This insight does NOT apply when the problem does not involve a directed network or flow conservation at intermediate nodes. For example, when the problem statement involves balancing supply and demand across locations without a network flow structure, such as in a transportation or assignment problem involving warehouses with specific supply and demand and transportation costs.",
    "explanation": "When the problem involves maintaining flow conservation at intermediate nodes, the best practice is to set the inflow equal to the outflow for each intermediate node. A common mistake is to incorrectly set the inflow minus outflow to zero for all nodes, including source and sink, which happens because of misunderstanding the special roles of source and sink. More generally, this reflects that flow conservation must exclude the source and sink nodes to properly model networks.",
    "example": "# Wrong: Apply flow conservation to all nodes including source and sink\n\\[\n\\sum_{j \\in V} x_{ij} = \\sum_{j \\in V} x_{ji} \\quad \\forall i \\in V\n\\]\n\n# Correct: Apply flow conservation only to intermediate nodes\nfor i in N:\n    if i != 0 and i != 7:\n        model.addConstr(gp.quicksum(flow[i, j] for j in N if (i, j) in capacities) ==\n                        gp.quicksum(flow[k, i] for k in N if (k, i) in capacities),\n                        name=f\"flow_conservation_{i}\")",
    "iteration": 0,
    "version": 1,
    "task_id": "E064",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "E067"
      ],
      "negative": [
        "E035"
      ],
      "unretrieved": [
        "E061",
        "E103"
      ],
      "irrelevant": [
        "E107",
        "E038",
        "E052",
        "B099"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 94,
    "taxonomy": {
      "Code Implementation": {
        "Data I/O & Validation": [
          "KeyError & Index Mismatch"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains indexed variables or parameters that are accessed with indices not present in the corresponding data structures. For example, when the formulation included accessing x[(0, j)] and x[(i, 7)] directly without checking their existence in the constraints.",
    "explanation": "When the problem involves accessing indexed elements in a dictionary. The best practice is to ensure that the indices exist in the data structure before access. A common mistake is directly accessing elements without validation, which happens because the programmer assumes all potential indices are valid. More generally, this reflects that direct access to data structures in a mathematical model should be verified to prevent runtime errors.",
    "example": "# Wrong: model.setObjective(gp.quicksum(x[0, j] for j in V if (0, j) in x) - gp.quicksum(x[i, 7] for i in V if (i, 7) in x), GRB.MAXIMIZE)\n# Correct: model.setObjective(gp.quicksum(x[0, j] for j in V if (0, j) in [(i, j) for i, j, cap in C]) - gp.quicksum(x[i, 7] for i in V if (i, 7) in [(i, j) for i, j, cap in C]), GRB.MAXIMIZE)",
    "iteration": 0,
    "version": 1,
    "task_id": "E064",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 95,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Quicksum vs. sum Syntax"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains linear expressions aggregated over large index sets that should be constructed using solver-native summation operators. For example, when the formulation included summing flows using gp.quicksum for capacity constraints.",
    "explanation": "When the problem involves constructing linear expressions over large sets. The best practice is to use solver-native functions like gp.quicksum for efficient computation. A common mistake is using Python's built-in sum function, which happens because the programmer might not be aware of solver-specific optimizations. More generally, this reflects that using appropriate solver-native functions can significantly enhance computational efficiency.",
    "example": "# Wrong: model.addConstrs((sum(x[i, j] for i, j, cap in C) <= cap for i, j, cap in C), 'capacity')\n# Correct: model.addConstrs((gp.quicksum(x[i, j] for i, j, cap in C) <= cap for i, j, cap in C), 'capacity')",
    "iteration": 0,
    "version": 1,
    "task_id": "E064",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 96,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem statement mentioned transportation of goods from a central warehouse to a retail hub through a network of cities.",
    "explanation": "When the problem involves maintaining flow balance at each node in a network. The best practice is to apply flow conservation constraints at each node, ensuring that inflow equals outflow plus any net supply or demand. A common mistake is to incorrectly apply or omit these constraints, which happens because of misunderstanding the necessity of balance at nodes or misapplying the flow equations. More generally, this reflects that accurately modeling network flow problems requires careful attention to nodal balance constraints to ensure feasible solutions.",
    "example": "# Wrong: x_{01} + x_{02} + x_{03} + x_{05} = x_{10} + x_{20} + x_{30} + x_{50} (at city 0)\n# Correct: Include conservation constraints for all intermediate nodes like those applied in the gold-standard program.",
    "iteration": 0,
    "version": 1,
    "task_id": "E072",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 97,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Parenthesis Matching Errors"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains complex expressions involving multiple operations that require careful attention to parenthesis matching. For example, when the formulation included constraints with multiple terms on both sides as in the flow conservation constraint for city 1.",
    "explanation": "When the problem involves writing constraints with complex expressions. The best practice is to ensure that all parentheses are correctly matched to avoid syntax errors. A common mistake is having unmatched parentheses, which happens because of oversight or miscounting during formulation. More generally, this reflects that in mathematical programming, correct expression parsing is crucial for solver interpretation.",
    "example": "# Wrong: flow[1, 0] + flow[1, 2] + flow[1, 3] + flow[1, 4] + flow[1, 5] == flow[0, 1] + flow[3, 1] + flow[4, 1] + flow[5, 1), \"Flow_1\")\n# Correct: flow[1, 0] + flow[1, 2] + flow[1, 3] + flow[1, 4] + flow[1, 5] == flow[0, 1] + flow[3, 1] + flow[4, 1] + flow[5, 1], \"Flow_1\")",
    "iteration": 0,
    "version": 1,
    "task_id": "E072",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 98,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem statement mentioned flow conservation equations for cities, ensuring the inflow minus outflow equals zero (or net demand) at each city. This insight applies when the problem description involves relocating resources across multiple locations and maintaining a balance between supply and demand in each location, or when quantities are moved between nodes in a network, specifically in transportation problems where supply and demand at each node must be balanced. This insight does NOT apply when [general situation that negates the insight]. For example, when the problem statement mentions [concrete trigger(s) grounded in the problem description or defining features indicating properties that conflict with the insight].",
    "explanation": "When the problem involves flow conservation in a network, the best practice is to ensure that for each node (except for source and sink), the total inflow equals the total outflow. A common mistake is incorrectly formulating or omitting these constraints, which happens because each node's balance equation is not properly defined, leading to incorrect flow calculations. More generally, this reflects that in network flow problems, maintaining accurate flow conservation equations is crucial for modeling the system correctly.",
    "example": "# Wrong: City 4 flow conservation is missing outflow terms: f_{40} + f_{41} + f_{42} + f_{43} + f_{45} = 0\n# Correct: Include all inflow and outflow terms: f_{40} + f_{41} + f_{42} + f_{43} + f_{45} - f_{04} - f_{14} - f_{24} - f_{34} = 0",
    "iteration": 0,
    "version": 1,
    "task_id": "E072",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "E038"
      ],
      "negative": [],
      "unretrieved": [
        "E107",
        "E035",
        "E066"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 99,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Arc-Capacity Constraints"
        ]
      }
    },
    "condition": "This insight applies when the problem domain contains edges with maximum throughput or capacity limits. For example, when the problem statement specified transportation capacity for each highway, indicating the maximum flow possible on each arc.",
    "explanation": "When the problem involves arc-capacity constraints in network flow, the best practice is to enforce flow bounds on each arc according to its capacity. A common mistake is forgetting to apply these capacity limits correctly, which happens because capacity constraints are not explicitly defined for each directed arc, allowing flows that exceed arc limits. More generally, this reflects that in network flow problems, respecting arc capacities is essential to ensure realistic and feasible solutions.",
    "example": "# Wrong: Missing capacity constraint for arc (1, 5): f_{15} <= 5\n# Correct: Include capacity constraint: model.addConstr(flow[1, 5] <= 5, 'cap_1_5')",
    "iteration": 0,
    "version": 1,
    "task_id": "E072",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "E071",
        "E069",
        "E061",
        "E059",
        "E067",
        "E066",
        "E052",
        "E103"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [
        "B099"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 100,
    "taxonomy": {},
    "condition": "This insight applies when the problem description requires maximizing throughput between designated source and sink nodes. For example, when the problem statement mentioned maximizing the flow of water from Distribution Center 0 (Source) to Center 8 (Sink) or maximizing the data flow from Data Center 0 to Data Center 7.",
    "explanation": "When the problem involves maximizing flow from a source to a sink, the best practice is to directly maximize the flow leaving the source (or entering the sink). A common mistake is incorrectly formulating the objective function by subtracting flow into the sink, which happens because of misunderstanding the max-flow objective. More generally, this reflects that the max-flow problem should be modeled to maximize the net flow out of the source or into the sink.",
    "example": "# Wrong: Maximize sum(x_0j) - sum(x_i8)\n# Correct: Maximize sum(f[0, j] for j in range(N))",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E064",
      "E071"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 101,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem statement involves water flow between distribution centers with conservation of flow at intermediary nodes.",
    "explanation": "When the problem involves flow conservation at nodes, the best practice is to ensure that the total inflow equals the total outflow for each non-source and non-sink node. A common mistake is omitting the flow conservation constraints or misapplying them, which happens because of neglecting the requirement to balance inflows and outflows at each node. More generally, this reflects that network flow problems require careful attention to nodal balance constraints.",
    "example": "# Wrong: sum(x_ij) = sum(x_ki), \u2200i \u2260 0, 8\n# Correct: model.addConstr(gp.quicksum(f[i, j] for j in range(N)) == gp.quicksum(f[j, i] for j in range(N)), \u2200i \u2260 S, T)",
    "iteration": 0,
    "version": 1,
    "task_id": "E071",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 102,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Variable Bound Syntax"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains decision variables with upper bounds that should be defined by an existing capacity matrix. For example, when the formulation included a capacity matrix `C` that sets the bounds for flow variables `x[i][j]` in a network flow model.",
    "explanation": "When the problem involves setting variable bounds using a predefined capacity matrix, the best practice is to use the matrix directly in the bound definition. A common mistake is using a function to dynamically set bounds, which happens because of misunderstanding how Gurobi's `addVars()` method interprets bounds. More generally, this reflects that solver APIs often expect static data structures for parameter definitions, which must be utilized correctly.",
    "example": "# Wrong\nx = model.addVars(N, N, lb=0.0, ub=lambda i, j: C[i][j], vtype=GRB.CONTINUOUS, name='x')\n\n# Correct\nx = model.addVars(N, N, lb=0.0, ub=C, vtype=GRB.CONTINUOUS, name='x')",
    "iteration": 0,
    "version": 1,
    "task_id": "E071",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 103,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Parameter Boundaries"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains decision variables that have specific upper and lower bounds based on problem data. For example, when the formulation included an upper bound for variables based on capacities.",
    "explanation": "When the problem involves setting bounds for decision variables. The best practice is to use a dictionary to specify individual bounds for each variable. A common mistake is using an aggregate expression like `gp.quicksum()`, which happens because the solver expects explicit bounds for each variable. More generally, this reflects that using correct data structures ensures parameters are interpreted correctly by the solver.",
    "example": "# Wrong: flow = model.addVars(capacities.keys(), lb=0, ub=gp.quicksum(capacities.values()), name='flow')\n# Correct: flow = model.addVars(capacities.keys(), lb=0, ub={key: capacity for key, capacity in capacities.items()}, name='flow')",
    "iteration": 0,
    "version": 1,
    "task_id": "E067",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 104,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision quantities in the problem represent divisible amounts such as flows or indivisible counts or choices. For example, when the problem statement involved modeling the flow of vehicles or the transportation of a maximum number of trucks from a warehouse to a retail hub.",
    "explanation": "When the problem involves modeling flows or counts, the best practice is to define flow variables as continuous for divisible amounts and integer for indivisible quantities. A common mistake is misdefining them as continuous or integer, which happens because of confusion over the nature of the decision quantity. More generally, this reflects that correctly choosing between continuous and discrete variables is vital for accurate and efficient optimization.",
    "example": "# Wrong: Defining flow variables as integer\nf_ij = model.addVars(capacities.keys(), vtype=GRB.INTEGER)\n\n# Correct: Defining flow variables as continuous\nf_ij = model.addVars(capacities.keys(), vtype=GRB.CONTINUOUS)\n\n# Wrong\nx_A, x_B, x_C are continuous\n\n# Correct\norders_A = model.addVar(vtype=GRB.INTEGER, name='Orders_A', lb=0)",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "B020",
      "E061",
      "E070",
      "E072"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 105,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Source and Sink Flow Balance"
        ]
      }
    },
    "condition": "This insight applies when modeling a network flow problem with specific source and sink nodes. For example, when the problem statement mentioned maximizing cargo flow from Hub 0 (source) to Hub 5 (sink), accurate flow balance at these nodes is crucial.",
    "explanation": "When the problem involves maximizing flow from a source to a sink, the best practice is to ensure the net outflow at the source is maximized and the net inflow at the sink is correctly captured. A common mistake is to incorrectly model these flows, as seen in the failed model where the net flow formulations for source and sink were incorrect. More generally, this reflects that correctly modeling source and sink flow balance is essential for accurate maximum flow calculations.",
    "example": "# Wrong\n\\sum_{j \\in V} f_{0j} \\leq \\sum_{j \\in V} f_{j0}\n# Correct\n\\sum_{j \\in V} f_{0j} - \\sum_{j \\in V} f_{j0} = \\text{max flow}",
    "iteration": 0,
    "version": 1,
    "task_id": "E053",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 106,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem requires maintaining flow conservation at hubs other than the source and sink.",
    "explanation": "When the problem involves maintaining flow conservation at intermediate nodes, the best practice is to ensure that the inflow equals the outflow for those nodes. A common mistake is to incorrectly apply flow conservation constraints, as seen in the failed model where flow conservation was not correctly applied to the source and sink. More generally, this reflects that accurate modeling of flow conservation is critical for feasible flow solutions in network problems.",
    "example": "# Wrong\n\\sum_{j \\in V} f_{ij} = \\sum_{j \\in V} f_{ji}, \\quad \\forall i \\in V \\setminus \\{0, 5\\}\n# Correct\n\\sum_{j \\in V} f_{ij} = \\sum_{j \\in V} f_{ji}, \\quad \\forall i \\in V \\setminus \\{0, 5\\}",
    "iteration": 0,
    "version": 1,
    "task_id": "E053",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 107,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Max-Flow Objective"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires maximizing throughput between designated source and sink nodes. This insight applies when the problem involves maximizing flow from a source to a sink in a network with defined capacities, ensuring the maximum inflow to the sink equals the maximum outflow from the source. This insight does NOT apply when the network does not have defined capacities or if the objective does not involve maximizing throughput between specific nodes.",
    "explanation": "When the problem involves maximizing flow from a source to a sink, the best practice is to explicitly define the objective as maximizing the flow out of the source or into the sink. A common mistake is to maximize the flow into the sink without subtracting any flow out of the source, which happens because inflow and outflow at the source are not independently considered. More generally, this reflects that network flow problems require careful formulation of the objective to ensure it captures the true intent of maximizing flow between specified nodes.",
    "example": "# Wrong: Maximize \\( \\sum_{i \\in V} f_{i5} \\)\n# Correct: Maximize \\( \\sum_{j \\in V} f_{0j} - \\sum_{i \\in V} f_{i0} \\)",
    "iteration": 0,
    "version": 1,
    "task_id": "E053",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [
        "E059"
      ],
      "unretrieved": [
        "E071",
        "E069",
        "E061",
        "E067",
        "E066",
        "E052",
        "E103",
        "B099"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 108,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem statement described flow conservation at intermediate nodes in a transportation network.",
    "explanation": "When the problem involves maintaining flow conservation at nodes, the best practice is to ensure that inflow equals outflow at each intermediate node. A common mistake is to apply flow conservation to all nodes including the source and sink, which happens because the unique roles of source and sink in network flow problems are overlooked. More generally, this reflects that network flow models must accurately represent the flow balance for nodes that are neither sources nor sinks.",
    "example": "# Wrong: \\( \\sum_{j \\in V} f_{ij} = \\sum_{j \\in V} f_{ji}, \\forall i \\in V \\)\n# Correct: \\( \\sum_{j \\in V} f_{ij} = \\sum_{j \\in V} f_{ji}, \\forall i \\in V \\setminus \\{0, 5\\} \\)",
    "iteration": 0,
    "version": 1,
    "task_id": "E053",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 109,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision quantities in the problem represent indivisible counts or choices versus divisible amounts such as flows. For example, when the problem statement described cargo flow in tons, which is naturally a continuous variable.",
    "explanation": "When the problem involves quantities that can be divided, such as cargo flow in tons, the best practice is to define them as continuous variables. A common mistake is to misdefine them as discrete when they are continuous, which happens because of an oversight in distinguishing between discrete and continuous quantities. More generally, this reflects that variable definitions in optimization models must align with the divisibility and nature of the quantities they represent.",
    "example": "# Wrong: Integer variable for cargo flow\n# Correct: Continuous variable for cargo flow",
    "iteration": 0,
    "version": 1,
    "task_id": "E053",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 110,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem requires that the total inflow equals total outflow for each station except the source and sink.\nThis insight applies when the problem involves determining the maximum flow through a network with directed edges and requires maintaining nodal balance for intermediate nodes. For example, when the problem statement specifies a network of nodes connected by directed edges with defined capacities and seeks to find the maximum flow from a source to a sink, ensuring that flow conservation constraints are applied at all intermediate nodes.\nThis insight does NOT apply when the problem statement involves undirected networks or when nodal balance is not a requirement.",
    "explanation": "When the problem involves flow conservation across nodes, the best practice is to ensure that the total inflow and outflow are balanced for intermediate nodes. A common mistake is to incorrectly apply or omit these conservation constraints, which happens because the balance condition can be overlooked or incorrectly formulated. More generally, this reflects that flow balance is essential for intermediate nodes to reflect real-world network conditions.",
    "example": "# Wrong\n\\sum_{j \\in S} f_{ji} = \\sum_{j \\in S} f_{ij} \\quad \\forall i \\in S \\setminus \\{0, 8\\}\n\n# Correct\nmodel.addConstr(gp.quicksum(flow[i, j] for j in range(N)) == gp.quicksum(flow[j, i] for j in range(N)), name=f\"flow_conservation_{i}\")",
    "iteration": 0,
    "version": 1,
    "task_id": "E069",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "E103"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 111,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem statement mentioned ensuring the flow of goods through each connection does not exceed its transportation capacity.",
    "explanation": "When the problem involves modeling network flow, the best practice is to ensure that the flow conservation constraints are correctly defined, where the total inflow equals the total outflow for each node except the source and destination. A common mistake is to incorrectly define the flow conservation constraints, as seen in the failed model where the flow from the source and to the destination was not properly balanced in the objective function, which happens because of misunderstanding of nodal flow conservation principles. More generally, this reflects that accurate flow conservation constraints are essential for solving network flow problems correctly.",
    "example": "# Wrong: Maximize \\( \\sum_{j \\in N} f_{0j} - \\sum_{i \\in N} f_{i8} \\)\n# Correct: Maximize \\( \\sum_{j \\in N} f_{0j} \\) subject to \\( \\sum_{j \\in N} f_{ji} = \\sum_{j \\in N} f_{ij} \\) for all nodes except 0 and 8",
    "iteration": 0,
    "version": 1,
    "task_id": "E066",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 112,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Max-Flow Objective"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires maximizing throughput between designated source and sink nodes. For example, when the problem statement mentioned calculating the maximum amount of data that can be transmitted from Station 0 (the source) to Station 8 (the destination). This insight applies when the problem involves maximizing flow from a designated source to a designated destination within a network of nodes and edges, where the flow must respect capacity constraints on the edges. For example, when the problem statement mentions determining the maximum quantity of water that can be distributed from a primary source (Station 0) to a central distribution hub (Station 8) in a network of pipelines with varying capacities. This insight does NOT apply when the problem involves optimizing network reliability or redundancy, rather than flow.",
    "explanation": "When the problem involves maximizing the total flow from a source to a sink, the best practice is to set the objective function to maximize the net flow from the source to the destination. A common mistake is incorrectly formulating the objective function, such as by subtracting flows into the source, which happens because it does not accurately represent the net flow from the source to the destination. More generally, this reflects that the objective function should clearly and directly represent the intended optimization goal.",
    "example": "# Wrong: \n\\[ \\max \\sum_{j \\in V} f_{sj} - \\sum_{i \\in V} f_{it} \\]\n# Correct: \nmodel.setObjective(gp.quicksum(flow[S, j] for j in range(N) if (S, j) in flow), GRB.MAXIMIZE)",
    "iteration": 0,
    "version": 1,
    "task_id": "E052",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [
        "E061",
        "E059",
        "E066",
        "E069",
        "E052",
        "E103"
      ],
      "unretrieved": [
        "E071",
        "E069"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 113,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. This insight applies when the problem involves either a directed network with intermediate nodal balance or a network where data capacity constraints are specified. This insight does NOT apply when there is no need for nodal balance due to either being an undirected network or having no intermediate nodes.",
    "explanation": "When the problem involves maintaining flow conservation across a network, the best practice is to enforce flow balance at all nodes except the source and sink. A common mistake is to apply incorrect flow conservation constraints, such as including the source or sink in conservation equations, which happens because it does not acknowledge that the source and sink are not subject to balance constraints. More generally, this reflects that conservation constraints should focus on intermediate nodes to ensure proper network flow modeling.",
    "example": "# Wrong: \n\\[ \\sum_{j \\in V} f_{ij} = \\sum_{j \\in V} f_{ji} \\quad \\forall i \\in V \\setminus \\{s, t\\} \\]\n# Correct: \nmodel.addConstrs((gp.quicksum(flow[i, j] for j in range(N) if (i, j) in flow) == gp.quicksum(flow[j, i] for j in range(N) if (j, i) in flow) for i in range(N) if i != S and i != D), name=\"flow_conservation_constraints\")",
    "iteration": 0,
    "version": 1,
    "task_id": "E052",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "E052"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 114,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Objective Function Specification"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains an objective function that should be constructed to reflect the intended optimization goal. For example, when the formulation included maximizing the flow from source (Station 0) to destination (Station 8).",
    "explanation": "When the problem involves optimizing a particular metric, the best practice is to clearly define an objective function that aligns with the intended optimization goal, such as maximizing total flow. A common mistake is to overlook the correct specification of the objective, which happens because of misinterpretation of the optimization requirements. More generally, this reflects that objective functions must be explicitly aligned with the optimization objectives of the model.",
    "example": "# Wrong: model.setObjective(gp.quicksum(flow[i, j] for i, j in E), GRB.MAXIMIZE)\n# Correct: model.setObjective(gp.quicksum(flow[0, j] for j in V if (0, j) in E), GRB.MAXIMIZE)",
    "iteration": 0,
    "version": 1,
    "task_id": "E052",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 115,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Arc-Capacity Constraints"
        ]
      }
    },
    "condition": "This insight applies when the problem domain contains edges with maximum throughput or capacity limits. This insight applies when the problem involves finding a path through a network where the path's overall performance is determined by the weakest link, such as maximizing the minimum bandwidth along the path. This insight does NOT apply when the problem statement mentions scenarios that do not involve throughput or capacity constraints, such as when the focus is on shortest path or path cost without considering bandwidth.",
    "explanation": "When the problem involves maximizing flow or bandwidth through a network, the best practice is to apply arc-capacity constraints to ensure that the flow on each arc does not exceed its capacity. A common mistake is failing to enforce these constraints, which happens because the model allows flows that are not feasible given the arc capacities. More generally, this reflects that arc-capacity constraints are crucial for maintaining feasible flow levels in network models.",
    "example": "# Wrong\nx_{ij} \\cdot b_{ij} \\leq \\min_{(i, j) \\in N \\times N} \\{ b_{ij} \\cdot x_{ij} \\} \\quad \\forall i, j \\in N\n\n# Correct\nB_{overall} \\leq b_{ij} + M \\cdot (1 - x_{ij}) \\quad \\forall i, j \\in N, \\text{where } M \\text{ is a large constant}",
    "iteration": 0,
    "version": 1,
    "task_id": "B099",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B099"
      ],
      "negative": [],
      "unretrieved": [
        "B099"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 116,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. This insight applies when both maximizing flow and maintaining nodal balance in a directed network are explicitly required. This insight does NOT apply when either the network is undirected or nodal balance is not relevant to the problem.",
    "explanation": "When the problem involves maintaining flow conservation at intermediate nodes, the best practice is to ensure that the inflow equals the outflow for these nodes. A common mistake is to incorrectly apply or omit flow conservation at certain nodes, which happens because of misinterpreting nodal balance requirements. More generally, this reflects that flow conservation must be accurately applied to ensure feasible solutions in network flow problems.",
    "example": "# Wrong: Apply flow conservation incorrectly for all nodes\n# Correct: Apply flow conservation only at intermediate nodes: sum(f_ij) = sum(f_ji) for i in {2, 3}",
    "iteration": 0,
    "version": 1,
    "task_id": "E102",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "E067",
        "B099"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 117,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Constraint Formulation Syntax"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains constraints that need to be added to the optimization model using the solver's syntax. For example, when the formulation included the constraint for Flow Conservation at Node 1, the correct syntax for adding an equality constraint was needed.",
    "explanation": "When the problem involves adding constraints to a model using a solver API. The best practice is to use the correct syntax for equality or inequality constraints that the solver expects. A common mistake is using incorrect arguments or too many positional arguments in constraint functions, which happens because the user misunderstands the API requirements or misuses the function signature. More generally, this reflects that understanding the solver's API syntax is crucial for correct model formulation.",
    "example": "# Wrong: model.addConstr(f_12 + f_13, GRB.EQUAL, 0, name=\"FlowConservation_Node1\")\n# Correct: model.addConstr(f_12 + f_13 == 0, name=\"FlowConservation_Node1\")",
    "iteration": 0,
    "version": 1,
    "task_id": "E103",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 118,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Variable Bounds"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains decision variables with bounds that should be aligned with specific constraints, capacities, or indices. For example, when the formulation included flow variables with bounds that were incorrectly set using expressions that depend on the decision variables themselves.",
    "explanation": "When the problem involves setting bounds for decision variables, the best practice is to use constant values or independent parameters for these bounds. A common mistake is setting bounds using expressions that depend on decision variables themselves, which happens because such constructs can create circular dependencies or incorrect constraints. More generally, this reflects that variable bounds in mathematical models should be clear, constant, and independent of the variables they bound.",
    "example": "# Wrong: f = model.addVars(V, V, lb=0, ub=gp.quicksum(C[i, j] for i, j in C), name='flow')\n# Correct: f = model.addVars(V, V, lb=0, ub=float('inf'), name='flow')\n# Wrong: flow = model.addVars(E, name=\"flow\", lb=0, ub=gp.quicksum(E.values()), vtype=GRB.CONTINUOUS)\n# Correct: flow = model.addVars(E, name=\"flow\", lb=0, ub=E, vtype=GRB.CONTINUOUS)",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E052",
      "E057",
      "E066",
      "E056"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 119,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Max-Flow Objective"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires maximizing throughput between designated source and sink nodes. For example, when the problem statement mentioned maximizing the total flow from a source node to a sink node.",
    "explanation": "When the problem involves maximizing flow from a source to a sink node, the best practice is to set the objective to maximize the flow into the sink node. A common mistake is to misinterpret the objective as maximizing the net flow from the source, which happens because it incorrectly accounts for outflows from the sink. More generally, this reflects that the objective should focus on the net inflow to the terminal node in a max-flow problem.",
    "example": "# Wrong: Maximize the net flow from source to sink: max sum(f_1j) - sum(f_i4)\n# Correct: Maximize the total flow into the sink: max sum(f_i4)\n# Wrong: Objective focuses on net flow out of source\nMaximize \\sum_{j \\in N} f_{0j} - \\sum_{i \\in N} f_{i8}\n\n# Correct: Objective focuses on flow into sink\nmodel.setObjective(gp.quicksum(flow[i, 8] for i in nodes), GRB.MAXIMIZE)",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E066",
      "E103",
      "E069",
      "E102"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [
        "E071"
      ],
      "negative": [
        "E103"
      ],
      "unretrieved": [],
      "irrelevant": [
        "B099"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 120,
    "taxonomy": {
      "General Formulation": {
        "Objective Specification": [
          "Redundant Auxiliary Variables"
        ]
      }
    },
    "condition": "This insight applies when auxiliary variables merely re-express existing linear combinations without adding modeling value. For example, when the problem statement involved directly placing flow expressions into the objective without auxiliary variables.",
    "explanation": "When the problem involves optimizing a specific network parameter, the best practice is to directly express the objective function without introducing redundant auxiliary variables. A common mistake is the use of auxiliary variables that unnecessarily complicate the model, which happens because the modeler does not recognize that the objective can be directly expressed. More generally, this reflects that clarity and simplicity in objective specification enhance model efficiency and solvability.",
    "example": "# Wrong: Introduce auxiliary variables for flow expressions\n# Correct: Directly use flow expressions in the objective: max sum(flow[i, 4] for i in [2, 3])\n# Wrong\nMaximize \\min_{(i,j) \\in V \\times V} \\{ b_{ij} \\cdot x_{ij} \\}\n\n# Correct\nmodel.setObjective(B_overall, GRB.MAXIMIZE)\nfor i in all_nodes:\n    for j in all_nodes:\n        if i != j and bw_data[i][j] > 0:\n            model.addConstr(B_overall <= bw_data[i][j] + max_possible_bandwidth * (1 - x[i, j]), name=f\"B_limit_{i}_{j}\")",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "B099",
      "E102"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 121,
    "taxonomy": {},
    "condition": "This insight applies when the problem involves making decisions about opening facilities and the associated costs and constraints must be linked to these decisions. For example, when the problem statement mentioned opening costs for each distribution center and the requirement that goods can only be transported from open centers, or when the problem description specifies that service or flow is allowed only if a facility is opened.",
    "explanation": "When the problem involves facility location with fixed costs and conditional operations, the best practice is to use Big-M constraints to link the operation of a facility to its opening decision. A common mistake is failing to correctly implement these Big-M constraints, which happens because the Big-M value may be improperly defined or the constraints may not effectively enforce the logical dependency. More generally, this reflects that accurately modeling fixed-charge facility location problems requires careful formulation of conditional constraints.",
    "example": "# Wrong: x_{ij} <= d_j y_i, which may not correctly enforce capacity-related constraints.\n# Correct: x_{ij} <= s_i y_i, ensuring that the center must be open (y_i=1) to transport any goods up to its full capacity.",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "B020",
      "E091"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 122,
    "taxonomy": {
      "Domain Modeling": {
        "Facility Location": [
          "Demand Fulfillment Constraints"
        ]
      }
    },
    "condition": "This insight applies when the problem requires the exact fulfillment of each retail store's demand from the distribution centers. For example, when the problem statement mentioned that each retail store has a specific demand that must be met exactly, the constraints should reflect equal fulfillment rather than allowing surplus.",
    "explanation": "When the problem involves fulfilling exact demands for retail stores, the best practice is to use equality constraints for demand fulfillment to ensure that the amount supplied meets exactly the demand. A common mistake is using inequality constraints that allow for surplus supply, which happens because the model allows more supply than required, potentially leading to higher costs. More generally, this reflects that precise demand fulfillment is critical in facility location problems where minimizing costs depends on meeting customer demand exactly.",
    "example": "# Wrong: \n\\[ \\sum_{i \\in I} x_{ij} \\geq d_j, \\quad \\forall j \\in J \\] \n\n# Correct: \n\\[ \\sum_{i \\in I} x_{ij} = d_j, \\quad \\forall j \\in J \\]",
    "iteration": 0,
    "version": 1,
    "task_id": "E079",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 123,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision variables represent either divisible amounts such as flows or indivisible counts such as the number of units shipped. For example, when the problem statement mentioned the number of units transported from distribution centers to stores, which should be modeled as continuous variables, or when shipping discrete units between facilities and retail stores, which requires integer variables.",
    "explanation": "When the problem involves transportation or flow of goods, the best practice is to define transportation variables as continuous to allow fractional flows. When dealing with discrete units, such as shipping quantities, the best practice is to define these as integer variables to reflect their indivisible nature. A common mistake is misusing integer or continuous variables, which happens because of misinterpretation of divisibility or indivisibility. More generally, this reflects the need to align variable types with the physical characteristics of the items being modeled.",
    "example": "# Wrong (flow): x = model.addVars(I, J, vtype=GRB.INTEGER, lb=0)\n# Correct (flow): x = model.addVars(I, J, vtype=GRB.CONTINUOUS, lb=0)\n\n# Wrong (discrete): model.addVars(centers, stores, vtype=GRB.CONTINUOUS, name=\"x\") \n# Correct (discrete): model.addVars(centers, stores, vtype=GRB.INTEGER, name=\"x\")",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E091",
      "E079"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [
        "B023"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 124,
    "taxonomy": {
      "General Formulation": {
        "Objective Specification": [
          "Redundant Auxiliary Variables"
        ]
      }
    },
    "condition": "This insight applies when auxiliary variables merely re-express existing linear combinations without adding modeling value. For example, when the problem statement required minimizing total travel cost and the failed model introduced unnecessary auxiliary variables.",
    "explanation": "When the problem involves specifying an objective function, the best practice is to directly use available decision variables and parameters. A common mistake is introducing redundant auxiliary variables, which happens because these variables do not simplify or add clarity to the objective. More generally, this reflects that avoiding unnecessary complexity in the objective function is important for model efficiency and clarity.",
    "example": "# Wrong\nMinimize \u2211_{i \u2208 N} \u2211_{j \u2208 N} c_{ij} \u00b7 x_{ij}\n# Correct\nmodel.setObjective(gp.quicksum(cost[i, j] * x[i, j] for i in C for j in C if i != j), GRB.MINIMIZE)",
    "iteration": 0,
    "version": 1,
    "task_id": "E041",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 125,
    "taxonomy": {
      "Domain Modeling": {
        "Routing": [
          "Subtour Elimination Constraints"
        ]
      }
    },
    "condition": "This insight applies when the problem description allows decision variables to form disconnected cycles that must be eliminated. For example, when the problem statement mentioned the requirement to visit each city exactly once and return to the starting city, ensuring there are no subtours is critical. This insight applies when the problem involves finding a single tour that visits each location exactly once and returns to the starting point, ensuring no subtours occur. For example, when the problem statement requires a path starting and ending at the same location with each city being visited exactly once, like in the Traveling Salesperson Problem (TSP) scenario, subtour elimination constraints are necessary. This insight does NOT apply when the problem does not require visiting each node exactly once or returning to the starting point in a single tour.",
    "explanation": "When the problem involves routing with potential for disconnected cycles, the best practice is to include effective subtour elimination constraints to ensure a single complete tour. A common mistake is omitting or incorrectly formulating these constraints, which happens because the model may allow solutions that consist of multiple disconnected loops. More generally, this reflects that subtour elimination constraints are essential in routing problems to ensure the solution is a valid tour.",
    "example": "# Wrong\nC3: u_i - u_j + |N| \u00b7 x_{ij} <= |N| - 1 for all i, j in N, i \u2260 j\n# Correct\nmodel.addConstrs((u[i] - u[j] + len(C) * x[i, j] <= len(C) - 1 for i in C for j in C if i != j and i != 1 and j != 1), name=\"subtour\")",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E043",
      "B069",
      "E041"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [
        "E044",
        "E046"
      ],
      "unretrieved": [
        "E045",
        "E044",
        "E046",
        "E050"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 126,
    "taxonomy": {
      "Domain Modeling": {
        "Routing": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires vehicles or agents to have balanced entry and exit at each visited node. For example, when the problem statement mentioned each city must be entered and left exactly once, it is vital to ensure the constraints reflect this exactly.",
    "explanation": "When the problem involves routing with balanced entry and exit, the best practice is to ensure flow conservation constraints are applied at every node with the correct relational operators. A common mistake is overlooking these constraints or using inequalities instead of equalities, which happens because the natural requirement of entering and exiting nodes is not explicitly enforced. More generally, this reflects that routing problems require explicit flow conservation and accurate relational operators to ensure feasible tours.",
    "example": "# Wrong: Use inequality instead of equality\nmodel.addConstrs((gp.quicksum(x[i, j] for j in cities if i != j) <= 1 for i in cities))\n\n# Correct: Ensuring flow conservation\nfor i in cities:\n    model.addConstr(gp.quicksum(x[i, j] for j in cities if j != i) == 1, name=f\"DepartOnce_{i}\")\nfor j in cities:\n    model.addConstr(gp.quicksum(x[i, j] for i in cities if i != j) == 1, name=f\"EnterOnce_{j}\")",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E043",
      "B069"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [
        "E045",
        "E044",
        "E046",
        "E050"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 127,
    "taxonomy": {
      "Domain Modeling": {
        "Routing": [
          "Subtour Elimination Constraints"
        ]
      }
    },
    "condition": "This insight applies when the problem description allows decision variables to form disconnected cycles that must be eliminated. For example, when the problem statement mentioned minimizing the travel cost for a delivery truck visiting each warehouse exactly once, it implies the need to avoid subtours. This insight applies when the problem description requires visiting each node exactly once in a cycle and returning to the starting point, with a specific focus on eliminating disconnected cycles or subtours. For example, when the problem statement involves minimizing the travel cost for a salesperson visiting each city exactly once and returning to the starting city, it implies the need to avoid subtours. This insight does NOT apply when the problem involves simple pathfinding without the need to revisit nodes or when the problem explicitly allows multiple visits to nodes, such as in pickup and delivery tasks.",
    "explanation": "When the problem involves planning routes that must visit each node exactly once without creating disconnected cycles, the best practice is to use subtour elimination constraints, such as the MTZ formulation. A common mistake is to incorrectly apply these constraints, which happens because their proper formulation and application can be complex. More generally, this reflects that subtour elimination is critical in routing problems to ensure feasible and optimal solutions.",
    "example": "# Wrong: u_i - u_j + |N| x_{ij} <= |N| - 1, where constraints are not properly applied to the starting node.\n# Correct: u[i] - u[j] + len(N) * x[i, j] <= len(N) - 1 for i != 'A' and j != 'A'.",
    "iteration": 0,
    "version": 1,
    "task_id": "E042",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "E045",
        "E046"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 128,
    "taxonomy": {
      "Domain Modeling": {
        "Routing": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires feasible vehicle tours with balanced entry and exit at each visited node. For example, when the problem statement mentioned the need for a delivery truck to visit each warehouse exactly once and return to the starting warehouse, flow conservation constraints ensure each warehouse is entered and exited exactly once.",
    "explanation": "When the problem involves routing a vehicle through a set of nodes, the best practice is to enforce flow conservation constraints at each node. A common mistake is to misapply these constraints, causing infeasibility or suboptimal routing, which happens because each node must be visited exactly once with balanced entry and exit. More generally, this reflects that flow conservation is essential in routing problems to maintain feasible tours.",
    "example": "# Wrong: sum(x[i][j] for j in N if j != i) != 1.\n# Correct: sum(x[i][j] for j in N if j != i) == 1 for all i in N.",
    "iteration": 0,
    "version": 1,
    "task_id": "E042",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 129,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem statement mentioned transporting empty containers from warehouses to ports with specific supply and demand constraints.\nThis insight applies when the problem domain involves strict satisfaction of production requirements, such as in manufacturing processes where products must be processed on specific machines, ensuring precise resource allocation and capacity planning.\nThis insight does NOT apply when there are no specific requirements for resource movement or allocation, or when the problem focuses on alternative objectives like cost minimization without strict demand satisfaction.",
    "explanation": "When the problem involves transporting resources between locations with specified supply and demand, the best practice is to use conservation equations that ensure all resources are appropriately accounted for at each node. A common mistake is to misinterpret the demand constraints by using inequalities that do not strictly satisfy the demand, which happens because of a misunderstanding of how demand should be fully met. More generally, this reflects that accurate modeling of resource balance is crucial in transportation and allocation problems.",
    "example": "# Wrong: \n\\[ \n\\sum_{i \\in W} x_{ij} \\geq D_j, \\quad \\forall j \\in P \n\\] \n# Correct: \n\\[ \n\\sum_{i \\in W} x_{ij} = D_j, \\quad \\forall j \\in P \n\\]",
    "iteration": 0,
    "version": 1,
    "task_id": "B006",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "B030"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 130,
    "taxonomy": {
      "Domain Modeling": {
        "Routing": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem statement involves transporting containers from warehouses to ports, each node should have balanced inflow and outflow according to supply and demand.",
    "explanation": "When the problem involves transporting goods through a network, the best practice is to ensure that inflow and outflow at each node (warehouse or port) are balanced according to the supply and demand. A common mistake is to overlook this balance, which happens because of a misinterpretation of flow conservation principles. More generally, this reflects the importance of maintaining flow conservation in network routing and transportation problems to ensure feasibility and correctness.",
    "example": "# Wrong: \nNo flow conservation constraints applied to nodes. \n# Correct: \nEnsure inflow - outflow = net demand for each node.",
    "iteration": 0,
    "version": 1,
    "task_id": "B006",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 131,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Integer Division Misuse"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains constraints that involve linear expressions needing proper handling of division. For example, when the formulation included constraints like limiting the number of items transported per truck capacity, using integer division wrongly distorted the constraint.",
    "explanation": "When the problem involves constraints dependent on capacity limits, the best practice is to ensure linear expressions remain linear and do not use integer division improperly. A common mistake is using integer division within the constraint expression, which happens because integer division can incorrectly alter the mathematical meaning of the constraint. More generally, this reflects that improper handling of mathematical operations can lead to constraints that do not correctly represent the intended logic.",
    "example": "# Wrong: model.addConstrs((x[i, j] <= truck_capacity * ((x[i, j] + truck_capacity - 1) // truck_capacity) for i in range(len(warehouses)) for j in range(len(ports))), name=\"TruckCapacity\")\n# Correct: model.addConstrs((x[i, j] <= truck_capacity for i in range(len(warehouses)) for j in range(len(ports))), name=\"TruckCapacity\")",
    "iteration": 0,
    "version": 1,
    "task_id": "B006",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 132,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, in the current problem, each type of good must be loaded into containers while respecting the total available quantity constraints.",
    "explanation": "When the problem involves resource allocation across different entities, the best practice is to ensure that conservation or balance equations accurately track the allocation and usage of resources. A common mistake is to omit these constraints or misformulate them, which happens because the importance of maintaining resource balance is underestimated. More generally, this reflects that properly formulated resource balance equations are critical for ensuring feasible solutions in resource allocation problems.",
    "example": "# Wrong: Omit constraints that ensure total goods loaded equal available quantities\n# Correct: Include constraints: sum(a_k) = Q_A, sum(b_k) = Q_B, etc.",
    "iteration": 0,
    "version": 1,
    "task_id": "B033",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 133,
    "taxonomy": {
      "Domain Modeling": {
        "Facility Location": [
          "Fixed Charge (Big-M Linking)"
        ]
      }
    },
    "condition": "This insight applies when the problem description specifies that service or flow is allowed only if a facility is opened. For example, in the current problem, containers should only be used if at least some goods are loaded into them.\n\nThis insight applies when the problem description specifies that a resource or option should be used under certain conditions, such as logical constraints or fixed costs. For example, mentioning either a choice between resources like bicycles or handcarts, or a fixed activation cost for a production line.\n\nThis insight does NOT apply when the problem lacks conditions that link resource usage to binary variables, or allows resource usage without specific constraints. For example, when there are no conditional usage logic requirements mentioned.",
    "explanation": "When the problem involves conditional resource usage, such as containers being used only when they are loaded, the best practice is to use big-M constraints to link binary usage variables with continuous or integer flow variables. A common mistake is to overlook this linkage, which happens because the conditional nature of resource usage is not explicitly enforced. More generally, this reflects the importance of correctly implementing conditional usage through big-M methods in facility location problems.",
    "example": "# Wrong: No constraint linking container usage to goods loading\n# Correct: Use big-M constraints: sum(weights[i] * x[i, k]) <= 60 * y[k]",
    "iteration": 0,
    "version": 1,
    "task_id": "B033",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "B062",
        "B021"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 134,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Strict Inequalities"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains constraints involving range inequalities that need to be decomposed into two separate constraints. For example, when the formulation included a compound inequality W_min <= expression <= W_max for a set of variables.",
    "explanation": "When the problem involves expressing range constraints as compound inequalities. The best practice is to split the compound inequality into two separate constraints. A common mistake is attempting to directly encode a range constraint using a single expression, which happens because solvers typically do not natively support compound inequalities. More generally, this reflects that solvers require each constraint to be expressed as a single inequality or equation.",
    "example": "# Wrong: model.addConstrs((W_min <= expression <= W_max for k in range(1000)), \"Capacity\")\n# Correct: model.addConstrs((expression >= W_min for k in range(1000)), \"Capacity_min\")\nmodel.addConstrs((expression <= W_max for k in range(1000)), \"Capacity_max\")",
    "iteration": 0,
    "version": 1,
    "task_id": "B033",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 135,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision quantities in the problem represent indivisible counts or choices versus divisible amounts such as flows. For example, when the problem statement requires specifying the number of containers transported or the number of units of goods loaded, which are indivisible units.",
    "explanation": "When the problem involves discrete decision variables, such as counts of items or binary decisions, the best practice is to define these variables as integer or binary types. A common mistake is to use continuous variables for indivisible items, which happens because the distinction between discrete and continuous quantities may be overlooked. More generally, this reflects that decision variables should match the nature of the items they represent, ensuring accuracy and feasibility in solutions.",
    "example": "# Wrong: var x[i,j] = m.addVar(vtype=GRB.CONTINUOUS, ...)\n# Correct: var x[i,j] = m.addVar(vtype=GRB.INTEGER, ...)\n# Wrong: Continuous variables for integer counts\ny_{Ak}, y_{Bk}, y_{Ck}, y_{Dk}, y_{Ek}: Continuous variables\n# Correct: Integer variables for discrete counts\nx = model.addVars(demands.keys(), max_containers, lb=0, ub=GRB.INFINITY, vtype=GRB.INTEGER, name='x')",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "B033",
      "B006"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [
        "B032",
        "B015"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 136,
    "taxonomy": {
      "General Formulation": {
        "Units Scaling": [
          "Unit Conversion & Consistency"
        ]
      }
    },
    "condition": "This insight applies when the problem involves multiple nutritional components measured in different units with the objective of minimizing cost. For example, when the problem statement mentioned protein in grams, minerals in grams, and vitamins in milligrams, while using price in \u00a5/kg.",
    "explanation": "When the problem involves nutritional requirements expressed in different units, the best practice is to ensure all units are consistent, especially in constraints and objectives. A common mistake is failing to convert units consistently, which happens because different components are measured in different scales. More generally, this reflects that all terms in a mathematical model must be expressed in compatible units to maintain correctness.",
    "example": "# Wrong: \n\\[ \\sum_{i=1}^{5} P_i \\cdot 1000 \\cdot x_i \\geq \\text{protein\\_req} \\]\n# Correct: \n\\[ \\sum_{i=1}^{5} P_i \\cdot x_i \\geq \\text{protein\\_req} \\text{ (converted to g/kg)} \\]",
    "iteration": 1,
    "version": 1,
    "task_id": "B029",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 137,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Indexing & Data Structure Alignment"
        ]
      }
    },
    "condition": "This insight applies when decision variables are indexed over a set or dictionary that must align with the keys of provided data. For example, in the feed mix optimization problem, variables are indexed by feed type and must match the indexing in the data structure used to store nutritional content and prices.",
    "explanation": "When the problem involves decision variables indexed over a set, the best practice is to ensure that the indices align correctly with the parameter keys. A common mistake is misaligning indices, which happens because of oversight in matching variable indices with data structures. More generally, this reflects that variable indices must be consistent with data sets to avoid errors such as KeyError.",
    "example": "# Wrong: \nx[i] = model.addVars([1, 2, 3, 5, 6], name=\"x\")\n# Correct: \nx = model.addVars(feed_ids, name=\"x\")",
    "iteration": 1,
    "version": 1,
    "task_id": "B029",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 138,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Strict Inequalities"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains strict inequality relations between variables that cannot be directly handled by LP/MIP solvers. For example, when the formulation included a requirement that the number of large planes must be strictly less than the number of small planes.",
    "explanation": "When the problem involves strict inequalities between decision variables. The best practice is to replace the strict inequality with an equivalent non-strict form that solvers can handle, such as using \u2264 with a subtraction adjustment for integer variables. A common mistake is attempting to directly use strict inequality operators like '<' within the solver constraints, which happens because most solvers, including Gurobi, do not support strict inequalities. More generally, this reflects that mathematical programming solvers require reformulation of strict inequalities into equivalent forms that are compatible with their APIs.",
    "example": "# Wrong\nmodel.addConstr(x_L < x_S, \"C2\")\n\n# Correct\nmodel.addConstr(x_L <= x_S - 1, \"C2\")",
    "iteration": 1,
    "version": 1,
    "task_id": "F050",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 139,
    "taxonomy": {
      "General Formulation": {
        "Objective Specification": [
          "Redundant Auxiliary Variables"
        ]
      }
    },
    "condition": "This insight applies when the problem involves maximizing an expected payout based on given probabilities and payouts for different options. For example, when the problem statement mentioned maximizing the average payout using different payout rates and probabilities of losing for each sport bet.",
    "explanation": "When the problem involves maximizing expected payout, the best practice is to use the expected return directly in the objective function. A common mistake is to not account for the probability of losing when calculating the expected payout, which happens because the objective does not include the probability of winning. More generally, this reflects that an accurate objective function should directly incorporate probabilities or expected values to align with the problem's goals.",
    "example": "# Wrong\nMaximize Z = 0.2 * x_B + 0.5 * x_H + 0.1 * x_S\n\n# Correct\nMaximize Z = 0.6 * x_B + 0.375 * x_H + 0.09 * x_S",
    "iteration": 1,
    "version": 1,
    "task_id": "A186",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 140,
    "taxonomy": {},
    "condition": "This insight applies when input data come from different unit systems or incompatible measurement scales. For example, when the problem statement mentioned machine processing times in minutes and total available processing time in hours, requiring consistent units for time constraints. Additionally, when the problem involves combining probabilities and monetary amounts in constraints, such as a constraint on the average probability of losing money over different bets.",
    "explanation": "When the problem involves different unit systems or incompatible measurement scales, the best practice is to ensure that all terms are consistently scaled or weighted to maintain unit consistency. A common mistake is to directly add or compare values without adjusting for their different units or scales, which happens because different types of data are treated as directly additive. More generally, this reflects that maintaining unit consistency is crucial to prevent erroneous constraints.",
    "example": "# Wrong\n(p_B * x_B + p_H * x_H + p_S * x_S) / Total_Amount \u2264 L\n\n# Correct\n0.5 * x_B + 0.25 * x_H + 0.10 * x_S \u2264 risk_limit",
    "iteration": 1,
    "version": 1,
    "task_id": [
      "B092",
      "B087",
      "A186"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 141,
    "taxonomy": {
      "General Formulation": {
        "Objective Specification": [
          "Sum vs. Makespan Confusion"
        ]
      }
    },
    "condition": "This insight applies when the objective involves minimizing machine usage time, and there is potential confusion between minimizing total hours or makespan. This insight applies when the objective involves minimizing operational hours or minimizing total processing cycle time in a setting where multiple products must be processed sequentially across multiple machines, and there is potential confusion between minimizing total hours or makespan. This insight does NOT apply when minimizing time does not require distinguishing between individual task and overall completion time.",
    "explanation": "When the problem involves minimizing the machine usage time, the best practice is to minimize the makespan, which is the maximum of the individual machine hours. A common mistake is minimizing the sum of hours, which happens because it does not account for the actual completion time when resources run in parallel. More generally, this reflects that distinguishing between total completion time and makespan is critical in scheduling and resource allocation problems.",
    "example": "# Wrong: Minimize x1 + x2\n# Correct: Minimize max_hour, with constraints max_hour >= x1 and max_hour >= x2",
    "iteration": 1,
    "version": 1,
    "task_id": "A104",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "A236",
        "B037",
        "A104"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 142,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain involves resource constraints that must be balanced or limited. This insight applies when the problem domain involves balancing multiple resource constraints that are interdependent. This insight applies when optimizing resource allocation involving multiple interdependent constraints requiring comprehensive balancing across the model. This insight does NOT apply when the optimization problem involves maximizing or minimizing economic indicators such as GDP, without explicitly focusing on balancing resource constraints. For example, when the problem statement mentions maximizing domestic GDP for Carelland's exports and imports without emphasizing the need for comprehensive balancing of resource constraints such as labor, material, or production limits.",
    "explanation": "When the problem involves resource constraints, the best practice is to ensure that resource consumption does not exceed the available supply. A common mistake is to overlook the comprehensive application of balance equations across all relevant constraints, which happens because partial application may not capture all resource interactions. More generally, this reflects that ensuring resource balance is essential in resource allocation problems.",
    "example": "# Wrong: Only partial application of balance equations\n# Correct: Apply resource balance equations comprehensively across all constraints",
    "iteration": 1,
    "version": 1,
    "task_id": "A104",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [
        "B039"
      ],
      "unretrieved": [
        "B039",
        "F167"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 143,
    "taxonomy": {
      "General Formulation": {
        "Objective Specification": [
          "Sum vs. Makespan Confusion"
        ]
      }
    },
    "condition": "This insight applies when a problem involves multiple resources or activities that can run in parallel and the objective is ambiguous between minimizing total completion time and the makespan. For example, in the car parking problem, the failed model attempts to minimize the total length of all parked cars, whereas the correct model aims to minimize the maximum length occupied on either side of the street.",
    "explanation": "When the problem involves allocating resources to minimize usage or time, the best practice is to clearly define whether the goal is to minimize the total sum or the maximum individual usage. In this problem, the best practice is to minimize the maximum length occupied on either side (makespan), rather than the total length. A common mistake is to minimize the total length, which happens because of a misinterpretation of the objective, leading to incorrect allocation. More generally, this reflects that distinguishing between sum and makespan objectives is crucial in optimization problems involving parallel resources.",
    "example": "# Wrong: Minimize total length\nminimize sum(lambda[i] * (x[i,1] + x[i,2]))\n\n# Correct: Minimize maximum length occupied on either side\nmodel.setObjective(L_max, GRB.MINIMIZE)",
    "iteration": 1,
    "version": 1,
    "task_id": "B080",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "B080"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 144,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Set-Partitioning/Assignment"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires each item or task to be exclusively assigned to exactly one choice among many. For example, in the car parking problem, each car should be parked on exactly one side of the street.",
    "explanation": "When the problem involves assigning items to one of several possible categories, the best practice is to ensure that each item is assigned to exactly one category using assignment constraints. In this problem, the best practice is to use constraints that ensure each car is parked on exactly one side of the street. A common mistake is to inadequately enforce this exclusivity, which happens because of improper constraint formulation. More generally, this reflects that set-partitioning or assignment constraints are essential when exclusive assignment is required.",
    "example": "# Wrong: \n# Constraints may not fully enforce exclusive assignment\nsum(x[i,1] + x[i,2]) <= 1\n\n# Correct: \n# Each car is parked on exactly one side\nsum(x[i,s] for s in sides) == 1 for each car i",
    "iteration": 1,
    "version": 1,
    "task_id": "B080",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B080"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 145,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Variable Scope in Constraints"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains constraints that need to be iteratively constructed over an index set. For example, when the formulation included constraints for each hour in a scheduling problem, iterating over a range of hours to ensure demand satisfaction.",
    "explanation": "When the problem involves iterating over a set to apply constraints, the best practice is to define all necessary variables and indices within the loop scope. A common mistake is referencing undefined variables, which happens because the loop variable is not defined outside the loop structure. More generally, this reflects that constraint definitions must be carefully scoped to include all necessary indices and variable references.",
    "example": "# Wrong: model.addConstr(gp.quicksum(x[i] for i in range(max(1, t-7), t+1)) >= d[t], name=f\"Demand_{t}\")\n# Correct: for t in T: model.addConstr(gp.quicksum(x[i] for i in range(max(1, t-7), t+1)) >= d[t], name=f\"Demand_{t}\")",
    "iteration": 1,
    "version": 1,
    "task_id": "B082",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 146,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Linearization of Non-linear Forms"
        ]
      }
    },
    "condition": "This insight applies when constraints involve nonlinear interactions between decision variables. For example, the failed mathematical model incorrectly applied the product of a binary variable with a continuous variable in the objective and constraints without proper linearization.",
    "explanation": "When the problem involves nonlinear expressions such as a product of binary and continuous variables, the best practice is to linearize these expressions using auxiliary variables and constraints. A common mistake is to directly input these nonlinear forms into the model, which happens because solvers like Gurobi require linear constraints for MIP problems. More generally, this reflects that linearization is essential to transform nonlinear components into a tractable linear form for optimization solvers.",
    "example": "# Wrong: Objective includes product V * y_V \nP_{\text{van}} \\cdot x_{\text{van}} * y_{\text{van}} \n\n# Correct: Introduce auxiliary variable and constraints \nw_V = V * y_V \nm.addConstr(w_V <= V)\nm.addConstr(w_V <= M * y_V)\nm.addConstr(w_V >= V - M * (1 - y_V))",
    "iteration": 1,
    "version": 1,
    "task_id": "B023",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 147,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Explicit Bounds"
        ]
      }
    },
    "condition": "This insight applies when decision variables have natural lower or upper bounds dictated by the problem description. For example, the failed mathematical model did not set explicit bounds for the number of trips for each vehicle type, despite having clear minimum requirements for truck trips.",
    "explanation": "When the problem involves decision variables with known bounds, the best practice is to explicitly set these bounds in the model. A common mistake is to omit these bounds or rely on implicit constraints, which can lead to incorrect or suboptimal solutions. More generally, this reflects that explicit bounds help solvers optimize more efficiently by reducing the feasible search space.",
    "example": "# Wrong: No explicit lower bound for truck trips\nx_{\text{truck}} \n\n# Correct: Explicit lower bound for truck trips\nx_{\text{truck}} \\geq T_{\text{min}}",
    "iteration": 1,
    "version": 1,
    "task_id": "B023",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "F122",
        "B049"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [
        "B062",
        "B015"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 148,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Fixed Charge (Big-M Linking)"
        ]
      }
    },
    "condition": "This insight applies when a problem involves discrete choices that activate or deactivate certain operations or costs. For example, the failed mathematical model used an incorrect approach by not properly linking the binary choice variables with the corresponding continuous variables for van and electric vehicle trips using Big-M constraints.",
    "explanation": "When the problem involves discrete decisions that control other variables, the best practice is to use Big-M constraints to link these binary decisions with the continuous variables they influence. A common mistake is to omit or incorrectly formulate these linking constraints, which happens because the logical relationship between the binary and continuous variables is not properly captured. More generally, this reflects that Big-M constraints are crucial for modeling fixed charge problems and ensuring the correct activation of costs or resources.",
    "example": "# Wrong: Missing correct Big-M linkage\nx_{\text{van}} \\leq M \\cdot y_{\text{van}} \n\n# Correct: Proper Big-M linkage\nm.addConstr(V <= M * y_V)",
    "iteration": 1,
    "version": 1,
    "task_id": "B023",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 149,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Variable Bounds"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains decision variables that are constrained by specific problem data. For example, when the formulation included flow variables bounded by the capacities of network edges.",
    "explanation": "When the problem involves setting up decision variables with specific bounds based on problem data. The best practice is to set these bounds directly using the data, such as the capacity of edges in a network flow problem. A common mistake is to use an incorrect bound, such as the sum of all capacities, which happens because of misunderstanding the role of bounds in constraining variables. More generally, this reflects that variable bounds should be precisely defined based on the constraints inherent in the problem data.",
    "example": "# Wrong\nf = model.addVars(V, V, lb=0, ub=gp.quicksum(C[i, j] for i, j in C), vtype=GRB.CONTINUOUS, name=\"f\")\n\n# Correct\nf = model.addVars(C.keys(), lb=0, ub=C, vtype=GRB.CONTINUOUS, name=\"f\")",
    "iteration": 1,
    "version": 1,
    "task_id": "E056",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 150,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Max-Flow Objective"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires maximizing throughput between designated source and sink nodes. For example, when the problem statement mentioned determining the maximum volume of water that can be efficiently distributed from Distribution Center 0 (the source) to Center 8 (the sink). This insight applies when either the problem involves defined source-sink pairs or when maximizing flow along a primary path is necessary. This insight does NOT apply when the problem involves determining the maximum flow in a network where the goal is to find the flow through all paths without distinct source and sink nodes, or when the problem is not explicitly about maximizing throughput between a designated source and sink. For example, when the problem statement involves multiple intermediate nodes and the end goal is to determine the maximum flow through a network without a clearly defined single source and sink pair.",
    "explanation": "When the problem involves maximizing flow from a source to a sink, the best practice is to explicitly maximize the flow out of the source into the network. A common mistake is focusing only on maximizing the flow into the sink, which happens because it might not capture all potential flow paths. More generally, this reflects that the objective should consider the total flow originating from the source when the goal is maximum network throughput.",
    "example": "# Wrong: \\( \\max \\sum_{i \\in N} f_{i8} \\)\n# Correct: \\( \\max \\sum_{j \\in N} f_{0j} \\)",
    "iteration": 1,
    "version": 1,
    "task_id": "E071",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "E069"
      ],
      "negative": [
        "E103"
      ],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 151,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem statement required ensuring inflow equals outflow at intermediate nodes. This insight applies when flow conservation is essential for maintaining network integrity across intermediate nodes. For example, when the problem statement mentions maintaining balanced inflow and outflow across nodes except for designated source and sink nodes. This insight does NOT apply when the problem involves a transportation or assignment problem where the goal is to minimize the cost of moving items between locations, and there is no directed network with intermediate nodes requiring flow balance. For example, when the problem statement mentions relocating freight cars among regions to meet demand without specifying intermediate nodes or flow conservation conditions.",
    "explanation": "When the problem involves maintaining flow conservation at each node, the best practice is to ensure inflow equals outflow at each node except the source and the sink. A common mistake is incorrectly formulating the constraints, such as by including the source or sink in flow conservation, which happens because these nodes naturally have imbalances reflecting net supply or demand. More generally, this reflects that flow conservation constraints should be applied only to intermediate nodes in a flow network.",
    "example": "# Wrong: \\( \\sum_{j \\in N} f_{ji} = \\sum_{j \\in N} f_{ij} \\quad \\forall i \\in N \\)\n# Correct: \\( \\sum_{j \\in N} f_{ji} = \\sum_{j \\in N} f_{ij} \\quad \\forall i \\in N \\setminus \\{0, 8\\} \\)",
    "iteration": 1,
    "version": 1,
    "task_id": "E071",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [
        "E107"
      ],
      "unretrieved": [],
      "irrelevant": [
        "E067",
        "E038"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 152,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Workload Distribution Constraints"
        ]
      }
    },
    "condition": "This insight applies when there is a requirement for a specific proportion of work to be allocated to a particular resource. For example, when the problem statement mentioned that at least a third of the work must be allocated to the specialized company.",
    "explanation": "When the problem involves workload distribution with specific proportion constraints, the best practice is to formulate these constraints directly in terms of the decision variables reflecting workload. A common mistake is to misinterpret these constraints as time allocations rather than workload allocations, which happens because the focus might be mistakenly placed on resource time rather than output. More generally, this reflects that workload distribution constraints should directly correspond to the output rather than the input resource usage.",
    "example": "# Wrong\nS_r \\cdot x_s \\geq \\frac{1}{3} \\cdot N\n\n# Correct\nx_s \\geq \\frac{1}{3} \\cdot (x_s + x_c)",
    "iteration": 2,
    "version": 1,
    "task_id": "A229",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 153,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Cost Efficiency Formulation"
        ]
      }
    },
    "condition": "This insight applies when different resources have distinct rates and costs per unit of output, requiring cost-efficient allocation. For example, when the problem statement mentioned differing annotation rates and costs between the specialized and common companies.",
    "explanation": "When the problem involves allocating resources with different output rates and costs, the best practice is to express costs in terms of cost per unit of output, which standardizes comparison across resources. A common mistake is to use cost per hour, which happens because it overlooks how different output rates affect the true cost efficiency. More generally, this reflects that cost efficiency should be formulated in terms of comparable units of output rather than input time or other metrics that obscure efficiency.",
    "example": "# Wrong\nZ = C_r \\cdot x_s + C_c \\cdot x_c\n\n# Correct\nZ = \\left(\\frac{C_r}{S_r}\\right) \\cdot x + \\left(\\frac{C_c}{S_c}\\right) \\cdot y",
    "iteration": 2,
    "version": 1,
    "task_id": "A229",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 154,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Incorrect Relational Operators"
        ]
      }
    },
    "condition": "This insight applies when natural-language statements such as 'at most' or 'at least' must be translated into algebraic inequalities. For example, when the problem statement mentioned that at least a third of the work must be allocated to the specialized company.",
    "explanation": "When the problem involves translating natural-language constraints into algebraic form, the best practice is to use the appropriate relational operators (\u2265, \u2264) to capture the intent ('at least', 'at most'). A common mistake is to misinterpret these constraints, which happens because of a failure to accurately translate natural language into mathematical form. More generally, this reflects that correctly interpreting and translating constraint language is crucial to maintaining model validity.",
    "example": "# Wrong\nS_r \\cdot x_s > \\frac{1}{3} \\cdot N\n\n# Correct\nS_r \\cdot x_s \\geq \\frac{1}{3} \\cdot N",
    "iteration": 2,
    "version": 1,
    "task_id": "A229",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 155,
    "taxonomy": {
      "Domain Modeling": {
        "Balancing": [
          "Load Balancing Constraints"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires fairness or controls maximum imbalance across parallel resources. For example, when the problem statement mentioned minimizing the difference in value between the two parts of the inheritance.",
    "explanation": "When the problem involves distributing resources or items between two agents to minimize imbalance, the best practice is to explicitly define constraints or objectives to achieve balance. A common mistake is using absolute value expressions directly in the objective, which happens because this introduces non-linearity and complicates solving. More generally, this reflects that formulating balance constraints directly can simplify optimization problems by maintaining linearity.",
    "example": "# Wrong: Minimize the absolute difference\n\\min \\left| \\sum_{i=1}^{14} V_i \\cdot x_i - \\sum_{i=1}^{14} V_i \\cdot (1 - x_i) \\right|\n\n# Correct: Use auxiliary variable with linear constraints\nm.setObjective(d, GRB.MINIMIZE)\nm.addConstr(2 * sum_values_y - V_total <= d, \"abs_diff_upper\")\nm.addConstr(-(2 * sum_values_y - V_total) <= d, \"abs_diff_lower\")",
    "iteration": 2,
    "version": 1,
    "task_id": "B032",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 156,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Linearization of Non-linear Forms"
        ]
      }
    },
    "condition": "This insight applies when nonlinear relations among variables reduce tractability or solver performance. For example, when the failed model attempted to minimize the absolute difference directly in the objective function, leading to non-linear formulation.",
    "explanation": "When the problem involves minimizing an absolute difference, the best practice is to linearize the expression using auxiliary variables and additional constraints. A common mistake is to include non-linear terms directly in the objective, which happens because it complicates the solution process for linear programming solvers. More generally, this reflects that linearization is essential for maintaining solver efficiency and tractability in optimization models.",
    "example": "# Wrong: Non-linear objective\n\\min \\left| \\sum_{i=1}^{14} V_i \\cdot x_i - \\sum_{i=1}^{14} V_i \\cdot (1 - x_i) \\right|\n\n# Correct: Linearized objective with auxiliary variable\nd = m.addVar(vtype=GRB.CONTINUOUS, name='d')\nm.setObjective(d, GRB.MINIMIZE)",
    "iteration": 2,
    "version": 1,
    "task_id": "B032",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 157,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision variables represent quantities that must be either continuous or discrete. For example, when the problem statement mentioned maximizing the number of complete products, z should have been modeled as an integer variable in the failed mathematical model.",
    "explanation": "When the problem involves optimizing the number of complete products, the best practice is to define the decision variable representing this quantity as an integer. A common mistake is to model it as a continuous variable, which happens because the variable type is not aligned with the intended discrete nature of the outcome. More generally, this reflects that decision variables should be carefully defined to match the discrete or continuous nature of the quantities they represent.",
    "example": "# Wrong: z is a continuous decision variable\nz = model.addVar(name='z', vtype=GRB.CONTINUOUS)\n\n# Correct: z is an integer decision variable\nz = model.addVar(name='z', vtype=GRB.INTEGER)",
    "iteration": 2,
    "version": 1,
    "task_id": "B031",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 158,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Linearization of Non-linear Forms"
        ]
      }
    },
    "condition": "This insight applies when constraints involve nonlinear relationships among decision variables. For example, when the failed mathematical model used division of variables to model component production constraints, which is a nonlinear form.",
    "explanation": "When the problem involves constraints that are nonlinear, such as division or multiplication of decision variables, the best practice is to linearize these constraints to maintain linearity of the model. A common mistake is to directly use nonlinear forms, which happens because they are not transformed into linear equivalents. More generally, this reflects that linearizing constraints can enhance model tractability and solvability.",
    "example": "# Wrong: Non-linear constraint\n1/R_{w1} * x_{w1} >= z\n\n# Correct: Linear constraint\nR_{w1} * x_{w1} >= z",
    "iteration": 2,
    "version": 1,
    "task_id": "B031",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 159,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem statement mentioned balancing production hours across workshops to produce components.",
    "explanation": "When the problem involves allocating limited production hours across multiple workshops, the best practice is to formulate constraints that ensure the total hours allocated do not exceed the available capacity for each workshop. A common mistake is to misrepresent these constraints, which happens because of incorrect application of resource balance principles. More generally, this reflects the need for accurate capacity/resource balance equations in resource allocation problems.",
    "example": "# Wrong: Missing or incorrect capacity constraints\nsum(x[w, c] for c in C) = H_w\n\n# Correct: Proper capacity constraints\nsum(x[w, c] for c in components) <= prod_capacity[w]",
    "iteration": 2,
    "version": 1,
    "task_id": "B031",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [
        "E107"
      ],
      "invalid": [
        "E038"
      ]
    }
  },
  {
    "insight_id": 160,
    "taxonomy": {
      "Domain Modeling": {
        "Production Planning": [
          "Shared Resource Constraints"
        ]
      }
    },
    "condition": "This insight applies when a production planning problem involves a shared resource constraint that limits overall production capacity. For example, when the problem statement mentioned a total of 22 production days available for all products together.",
    "explanation": "When the problem involves shared resource constraints, the best practice is to explicitly model these constraints to ensure total resource use does not exceed the available capacity. A common mistake is to omit such constraints, which can lead to infeasible or suboptimal solutions because the model does not respect the overall resource limitations. More generally, this reflects that shared resource constraints are crucial in ensuring feasibility and optimality in production planning models.",
    "example": "# Wrong\n# Shared resource constraint was missing in the failed model.\n# Correct\nmodel.addConstr(gp.quicksum(produce_qty[p] / production_quota[p] for p in products) <= available_days, \"TotalProductionTime\")",
    "iteration": 2,
    "version": 1,
    "task_id": "B021",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 161,
    "taxonomy": {
      "General Formulation": {
        "Big-M & Indicator Variables": []
      }
    },
    "condition": "This insight applies when the model uses binary variables to control whether a production line is active, with production quantities linked to these variables via a Big-M constraint. For example, when the problem statement requires production only when the production line is activated, but the failed model uses a loose Big-M constraint.",
    "explanation": "When the problem involves using Big-M constraints to model activation conditions, the best practice is to choose a tight Big-M value based on realistic upper bounds to avoid numerical instability and overly loose formulations. A common mistake is using a generic or excessively large M, which can lead to poor solver performance and inaccuracies because it unnecessarily enlarges the feasible region. More generally, this reflects that careful selection of Big-M values is essential for numerical stability and tighter formulations in optimization models.",
    "example": "# Wrong\nx_i <= M * y_i\n# Correct\nx_i <= max_demand[i] * y_i",
    "iteration": 2,
    "version": 1,
    "task_id": "B021",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 162,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Loop Variable Definition"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains constraints that need to be iterated over a defined set of indices. For example, when the formulation included constraints iterating over time periods T, the loop variable 't' needed explicit definition.",
    "explanation": "When the problem involves iterating over defined sets or ranges. The best practice is to explicitly define the loop variable within the iteration context. A common mistake is using an undefined or incorrect loop variable, which happens because the modeler assumes implicit recognition of the intended index set. More generally, this reflects that iteration over sets in modeling requires explicit and correct loop variable definitions to ensure context-aware iteration.",
    "example": "# Wrong: model.addConstr(gp.quicksum(x[i] for i in range(max(1, t-7), t+1)) >= d[t])\n# Correct: for t in T: model.addConstr(gp.quicksum(x[i] for i in range(max(1, t-7), t+1)) >= d[t])",
    "iteration": 2,
    "version": 1,
    "task_id": "B082",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 163,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Time Period Wrap-around Handling"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains constraints that span cyclic or wrap-around periods. For example, when the formulation included constraints for time periods 1 to 6, the constraints needed to handle wrap-around from end to start of the day.",
    "explanation": "When the problem involves cyclic or wrap-around schedules. The best practice is to implement constraints that correctly account for overlaps. A common mistake is assuming linear index progression without accounting for the cyclic nature, which happens because the modeler overlooks the need for special handling of boundary conditions. More generally, this reflects that cyclic schedule modeling requires explicit handling of wrap-around constraints to maintain model validity.",
    "example": "# Wrong: model.addConstr(gp.quicksum(x[i] for i in range(24+t-7, 25)) + gp.quicksum(x[i] for i in range(1, t+1)) >= d[t])\n# Correct: for t in range(1, 7): model.addConstr(gp.quicksum(x[i] for i in range(24+t-7, 25)) + gp.quicksum(x[i] for i in range(1, t+1)) >= d[t])",
    "iteration": 2,
    "version": 1,
    "task_id": "B082",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 164,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Variable Declaration Before Use"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains constraints or expressions that involve decision variables. For example, when the formulation included using binary variables x_A_bin and x_B_bin in constraints before declaring them.",
    "explanation": "When the problem involves declaring and using decision variables. The best practice is to declare all decision variables before they are used in constraints or objective functions. A common mistake is to reference variables before their declaration, which happens because users assume implicit declaration or overlook the order of operations. More generally, this reflects that all components of the model must be properly initialized before use.",
    "example": "# Wrong: model.addGenConstrIndicator(x_A_bin, True, x_A >= 1, \"C3_bin\")\n# Correct: x_A_bin = model.addVar(vtype=GRB.BINARY, name=\"x_A_bin\")",
    "iteration": 2,
    "version": 1,
    "task_id": "B018",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 165,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Correct Use of Indicator Constraints"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains conditional constraints that need to be enforced using indicator constraints. For example, when the formulation included imposing conditions on x_A and x_B through binary indicators x_A_bin and x_B_bin.",
    "explanation": "When the problem involves conditional constraints. The best practice is to use the addGenConstrIndicator method with correct syntax, specifying the binary variable, its value, the target variable, and the comparison sense. A common mistake is to omit the sense argument, which happens because users may be unfamiliar with the specific API requirements. More generally, this reflects that understanding the solver's API syntax is crucial for correct model formulation.",
    "example": "# Wrong: model.addGenConstrIndicator(x_A_bin, True, x_A >= 1, \"C3_bin\")\n# Correct: model.addGenConstrIndicator(x_A_bin, True, x_A, GRB.GREATER_EQUAL, 1, \"C3_bin\")",
    "iteration": 2,
    "version": 1,
    "task_id": "B018",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 166,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Variable Bound Specification Errors"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains decision variables whose upper bounds are determined by dictionary parameters. For example, when defining the flow variables 'f' with bounds specified by the capacity dictionary 'C'.",
    "explanation": "When the problem involves decision variables with bounds defined by a parameter dictionary. The best practice is to explicitly use dictionary comprehension to set bounds. A common mistake is using a linear expression or a single aggregated value as a bound, which happens because of misunderstanding how the solver interprets expressions for bounds. More generally, this reflects that bounds for variables should be directly derivable from data structures representing constraints to avoid unintended model behavior.",
    "example": "# Wrong\nf = model.addVars(C.keys(), lb=0, ub=gp.quicksum(C.values()), vtype=GRB.CONTINUOUS, name='f')\n\n# Correct\nf = model.addVars(C.keys(), lb=0, ub={key: C[key] for key in C}, vtype=GRB.CONTINUOUS, name='f')",
    "iteration": 2,
    "version": 1,
    "task_id": "E070",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 167,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Max-Flow Objective"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires maximizing throughput between designated source and sink nodes. For example, when the problem statement mentioned maximizing the water flow from Station 0 (source) to Station 8 (destination).",
    "explanation": "When the problem involves maximizing flow from a source to a destination in a network, the best practice is to set the objective to maximize the flow from source to sink. A common mistake is to maximize flow out of the source without ensuring it matches the flow into the destination, which happens because the objective fails to enforce the necessary balance between source output and sink input. More generally, this reflects that the objective in max-flow problems should capture the net flow from the source to the sink directly to correctly model the throughput goal.",
    "example": "# Wrong\n\\max \\sum_{j \\in N} f_{0j}\n\n# Correct\nmodel.setObjective(gp.quicksum(flow[0, j] for j in range(N)) == gp.quicksum(flow[i, 8] for i in range(N)), GRB.MAXIMIZE)",
    "iteration": 2,
    "version": 1,
    "task_id": "E069",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 168,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem statement requires ensuring that the inflow equals the outflow at intermediate nodes in the water distribution network.",
    "explanation": "When the problem involves flow through a network, the best practice is to enforce flow conservation at each node except the source and sink. A common mistake is to apply flow conservation constraints only to intermediate nodes, which happens because it overlooks the necessary equality between total outflow from the source and inflow into the sink. More generally, this reflects that flow conservation must be considered for the entire network, maintaining balance at each node and between source and sink.",
    "example": "# Wrong\n\\sum_{j \\in N} f_{ij} = \\sum_{j \\in N} f_{ji}, \\quad \\forall i \\in N \\setminus \\{0, 8\\}\n\n# Correct\nmodel.addConstr(gp.quicksum(flow[0, j] for j in range(N)) == gp.quicksum(flow[i, 8] for i in range(N)), name=\"source_to_destination_flow\")",
    "iteration": 2,
    "version": 1,
    "task_id": "E069",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 169,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, in the China Railroad Ministry problem, each region should have a balance between cars sent out and cars received, considering its supply and demand.",
    "explanation": "When the problem involves quantities moving through a network, the best practice is to ensure flow conservation at each node, meaning inflow minus outflow equals net demand. A common mistake is omitting or incorrectly formulating these conservation equations, which happens because the modeler fails to account for the full balance of resources at each node. More generally, this reflects that any transportation or flow problem requires precise flow balance to accurately model the system dynamics.",
    "example": "# Wrong: \n\\[ \\sum_{j \\in R, j \\neq i} x_{ij} - \\sum_{j \\in R, j \\neq i} x_{ji} = s_i - d_i, \\forall i \\in R \\]  \n# Correct: \n\\[ \\sum_{j \\in R, j \\neq i} x_{ij} - \\sum_{j \\in R, j \\neq i} x_{ji} = s_i - d_i, \\forall i \\in R \\text{ (Ensure this correctly reflects the net car flow)} \\]",
    "iteration": 2,
    "version": 1,
    "task_id": "E107",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 170,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision quantities in the problem represent indivisible counts or choices versus divisible amounts such as flows. For example, when the optimization task involves moving freight cars, which are discrete entities, between regions.",
    "explanation": "When the problem involves integer quantities, such as cars, the best practice is to define decision variables as integers. A common mistake is defining these variables as continuous, which happens because the modeler may overlook the indivisibility of the decision units. More generally, this reflects that decision variables should be defined according to the nature of the items being modeled, ensuring appropriate representation of discrete versus continuous quantities.",
    "example": "# Wrong: \nx_{ij} \\in \\mathbb{R}^+, \\forall i, j \\in R, i \\neq j  \n# Correct: \nx_{ij} \\in \\mathbb{Z}^+, \\forall i, j \\in R, i \\neq j",
    "iteration": 2,
    "version": 1,
    "task_id": "E107",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 171,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Decomposition"
        ]
      }
    },
    "condition": "This insight applies when a problem involves finding a path or route in a network that must pass through specific nodes in a given order. For example, when the problem statement mentioned establishing a link between node A and node E that must pass through node C.",
    "explanation": "When the problem involves specifying a path with particular intermediate nodes, the best practice is to decompose the path into sub-paths that connect the specified nodes sequentially. A common mistake is to model the entire path as a single flow without considering the intermediate requirements, which happens because the constraints for specific sequences are not explicitly enforced. More generally, this reflects that constraints must be set to ensure paths adhere to required sequences rather than assuming that a general flow will satisfy them.",
    "example": "# Wrong\nsum_{i in N} x_{iC} = 1\n\n# Correct\n# Path A to C\nsum_{j in N} x[start_node, j] == 1\nsum_{i in N} x[i, intermediate_node] == 1\n# Path C to E\nsum_{j in N} y[intermediate_node, j] == 1\nsum_{i in N} y[i, end_node] == 1",
    "iteration": 2,
    "version": 1,
    "task_id": "B099",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 172,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Big-M & Indicator Variables"
        ]
      }
    },
    "condition": "This insight applies when constraints depend on logical on/off conditions controlled by binary variables. For example, when the problem statement involves ensuring the path bandwidth does not exceed the capacity of any link used in the path.",
    "explanation": "When the problem involves constraints that are conditional on the use of specific links, the best practice is to use Big-M constraints to enforce conditional relationships based on binary variables. A common mistake is to fail to properly calibrate the Big-M value, which happens because M is not tightly bound to realistic limits or is not used effectively to enforce binary conditions. More generally, this reflects that Big-M should be chosen carefully to maintain numerical stability and logical correctness.",
    "example": "# Wrong\nB <= b_{ij} * x_{ij} + M * (1 - x_{ij})\n\n# Correct\nB_overall <= bw_data[i][j] + max_possible_bandwidth * (1 - x[i, j])",
    "iteration": 2,
    "version": 1,
    "task_id": "B099",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 173,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Variable Declaration with Integer Ranges"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains variable declarations that require integer range specifications. For example, when the formulation included `max_containers` derived from an arithmetic division, it needed to be explicitly converted to an integer before being used in `addVars()`.",
    "explanation": "When the problem involves defining variables based on a calculated bound, such as `max_containers`. The best practice is to ensure the bound is converted to an integer before use. A common mistake is neglecting this conversion, which happens because arithmetic operations may result in float values. More generally, this reflects that solver APIs often expect integer values for range specifications in variable declarations.",
    "example": "# Wrong: x = model.addVars(max_containers, vtype=GRB.BINARY, name=\"x\")\n# Correct: x = model.addVars(int(max_containers), vtype=GRB.BINARY, name=\"x\")",
    "iteration": 2,
    "version": 1,
    "task_id": "B033",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  }
]